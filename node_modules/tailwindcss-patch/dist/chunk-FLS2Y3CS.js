"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;// ../../node_modules/.pnpm/tsup@8.5.1_jiti@2.6.1_postcss@8.5.6_tsx@4.21.0_typescript@5.9.3_yaml@2.8.2/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL(`file:${__filename}`).href : document.currentScript && document.currentScript.tagName.toUpperCase() === "SCRIPT" ? document.currentScript.src : new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// src/logger.ts
var _consola = require('consola');
var logger = _consola.createConsola.call(void 0, );
var logger_default = logger;

// src/cache/store.ts
var _process = require('process'); var _process2 = _interopRequireDefault(_process);
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
function isErrnoException(error) {
  return error instanceof Error && typeof error.code === "string";
}
var CacheStore = class {
  constructor(options) {
    this.options = options;
  }
  async ensureDir() {
    await _fsextra2.default.ensureDir(this.options.dir);
  }
  ensureDirSync() {
    _fsextra2.default.ensureDirSync(this.options.dir);
  }
  createTempPath() {
    const uniqueSuffix = `${_process2.default.pid}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
    return `${this.options.path}.${uniqueSuffix}.tmp`;
  }
  async replaceCacheFile(tempPath) {
    try {
      await _fsextra2.default.rename(tempPath, this.options.path);
    } catch (error) {
      if (isErrnoException(error) && (error.code === "EEXIST" || error.code === "EPERM")) {
        try {
          await _fsextra2.default.remove(this.options.path);
        } catch (removeError) {
          if (!isErrnoException(removeError) || removeError.code !== "ENOENT") {
            throw removeError;
          }
        }
        await _fsextra2.default.rename(tempPath, this.options.path);
        return;
      }
      throw error;
    }
  }
  replaceCacheFileSync(tempPath) {
    try {
      _fsextra2.default.renameSync(tempPath, this.options.path);
    } catch (error) {
      if (isErrnoException(error) && (error.code === "EEXIST" || error.code === "EPERM")) {
        try {
          _fsextra2.default.removeSync(this.options.path);
        } catch (removeError) {
          if (!isErrnoException(removeError) || removeError.code !== "ENOENT") {
            throw removeError;
          }
        }
        _fsextra2.default.renameSync(tempPath, this.options.path);
        return;
      }
      throw error;
    }
  }
  async cleanupTempFile(tempPath) {
    try {
      await _fsextra2.default.remove(tempPath);
    } catch (e2) {
    }
  }
  cleanupTempFileSync(tempPath) {
    try {
      _fsextra2.default.removeSync(tempPath);
    } catch (e3) {
    }
  }
  async write(data) {
    if (!this.options.enabled) {
      return void 0;
    }
    const tempPath = this.createTempPath();
    try {
      await this.ensureDir();
      await _fsextra2.default.writeJSON(tempPath, Array.from(data));
      await this.replaceCacheFile(tempPath);
      return this.options.path;
    } catch (error) {
      await this.cleanupTempFile(tempPath);
      logger_default.error("Unable to persist Tailwind class cache", error);
      return void 0;
    }
  }
  writeSync(data) {
    if (!this.options.enabled) {
      return void 0;
    }
    const tempPath = this.createTempPath();
    try {
      this.ensureDirSync();
      _fsextra2.default.writeJSONSync(tempPath, Array.from(data));
      this.replaceCacheFileSync(tempPath);
      return this.options.path;
    } catch (error) {
      this.cleanupTempFileSync(tempPath);
      logger_default.error("Unable to persist Tailwind class cache", error);
      return void 0;
    }
  }
  async read() {
    if (!this.options.enabled) {
      return /* @__PURE__ */ new Set();
    }
    try {
      const exists = await _fsextra2.default.pathExists(this.options.path);
      if (!exists) {
        return /* @__PURE__ */ new Set();
      }
      const data = await _fsextra2.default.readJSON(this.options.path);
      if (Array.isArray(data)) {
        return new Set(data.filter((item) => typeof item === "string"));
      }
    } catch (error) {
      if (isErrnoException(error) && error.code === "ENOENT") {
        return /* @__PURE__ */ new Set();
      }
      logger_default.warn("Unable to read Tailwind class cache, removing invalid file.", error);
      try {
        await _fsextra2.default.remove(this.options.path);
      } catch (cleanupError) {
        logger_default.error("Failed to clean up invalid cache file", cleanupError);
      }
    }
    return /* @__PURE__ */ new Set();
  }
  readSync() {
    if (!this.options.enabled) {
      return /* @__PURE__ */ new Set();
    }
    try {
      const exists = _fsextra2.default.pathExistsSync(this.options.path);
      if (!exists) {
        return /* @__PURE__ */ new Set();
      }
      const data = _fsextra2.default.readJSONSync(this.options.path);
      if (Array.isArray(data)) {
        return new Set(data.filter((item) => typeof item === "string"));
      }
    } catch (error) {
      if (isErrnoException(error) && error.code === "ENOENT") {
        return /* @__PURE__ */ new Set();
      }
      logger_default.warn("Unable to read Tailwind class cache, removing invalid file.", error);
      try {
        _fsextra2.default.removeSync(this.options.path);
      } catch (cleanupError) {
        logger_default.error("Failed to clean up invalid cache file", cleanupError);
      }
    }
    return /* @__PURE__ */ new Set();
  }
};

// src/extraction/candidate-extractor.ts
var _fs = require('fs');

var _pathe = require('pathe'); var _pathe2 = _interopRequireDefault(_pathe);
async function importNode() {
  return Promise.resolve().then(() => _interopRequireWildcard(require("@tailwindcss/node")));
}
async function importOxide() {
  return Promise.resolve().then(() => _interopRequireWildcard(require("@tailwindcss/oxide")));
}
async function extractRawCandidatesWithPositions(content, extension = "html") {
  const { Scanner } = await importOxide();
  const scanner = new Scanner({});
  const result = scanner.getCandidatesWithPositions({ content, extension });
  return result.map(({ candidate, position }) => ({
    rawCandidate: candidate,
    start: position,
    end: position + candidate.length
  }));
}
async function extractRawCandidates(sources) {
  const { Scanner } = await importOxide();
  const scanner = new Scanner({
    sources
  });
  return scanner.scan();
}
async function extractValidCandidates(options) {
  const providedOptions = _nullishCoalesce(options, () => ( {}));
  const defaultCwd = _nullishCoalesce(providedOptions.cwd, () => ( _process2.default.cwd()));
  const base = _nullishCoalesce(providedOptions.base, () => ( defaultCwd));
  const css = _nullishCoalesce(providedOptions.css, () => ( '@import "tailwindcss";'));
  const sources = (_nullishCoalesce(providedOptions.sources, () => ( [
    {
      base: defaultCwd,
      pattern: "**/*",
      negated: false
    }
  ]))).map((source) => ({
    base: _nullishCoalesce(source.base, () => ( defaultCwd)),
    pattern: source.pattern,
    negated: source.negated
  }));
  const { __unstable__loadDesignSystem } = await importNode();
  const designSystem = await __unstable__loadDesignSystem(css, { base });
  const candidates = await extractRawCandidates(sources);
  const parsedCandidates = candidates.filter(
    (rawCandidate) => designSystem.parseCandidate(rawCandidate).length > 0
  );
  if (parsedCandidates.length === 0) {
    return parsedCandidates;
  }
  const cssByCandidate = designSystem.candidatesToCss(parsedCandidates);
  const validCandidates = [];
  for (let index = 0; index < parsedCandidates.length; index++) {
    const css2 = cssByCandidate[index];
    if (typeof css2 === "string" && css2.trim().length > 0) {
      validCandidates.push(parsedCandidates[index]);
    }
  }
  return validCandidates;
}
function normalizeSources(sources, cwd) {
  const baseSources = _optionalChain([sources, 'optionalAccess', _ => _.length]) ? sources : [
    {
      base: cwd,
      pattern: "**/*",
      negated: false
    }
  ];
  return baseSources.map((source) => ({
    base: _nullishCoalesce(source.base, () => ( cwd)),
    pattern: source.pattern,
    negated: source.negated
  }));
}
function buildLineOffsets(content) {
  const offsets = [0];
  for (let i = 0; i < content.length; i++) {
    if (content[i] === "\n") {
      offsets.push(i + 1);
    }
  }
  if (offsets[offsets.length - 1] !== content.length) {
    offsets.push(content.length);
  }
  return offsets;
}
function resolveLineMeta(content, offsets, index) {
  let low = 0;
  let high = offsets.length - 1;
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    const start = offsets[mid];
    const nextStart = _nullishCoalesce(offsets[mid + 1], () => ( content.length));
    if (index < start) {
      high = mid - 1;
      continue;
    }
    if (index >= nextStart) {
      low = mid + 1;
      continue;
    }
    const line = mid + 1;
    const column = index - start + 1;
    const lineEnd = content.indexOf("\n", start);
    const lineText = content.slice(start, lineEnd === -1 ? content.length : lineEnd);
    return { line, column, lineText };
  }
  const lastStart = _nullishCoalesce(offsets[offsets.length - 2], () => ( 0));
  return {
    line: offsets.length - 1,
    column: index - lastStart + 1,
    lineText: content.slice(lastStart)
  };
}
function toExtension(filename) {
  const ext = _pathe2.default.extname(filename).replace(/^\./, "");
  return ext || "txt";
}
function toRelativeFile(cwd, filename) {
  const relative = _pathe2.default.relative(cwd, filename);
  return relative === "" ? _pathe2.default.basename(filename) : relative;
}
async function extractProjectCandidatesWithPositions(options) {
  const cwd = _optionalChain([options, 'optionalAccess', _2 => _2.cwd]) ? _pathe2.default.resolve(options.cwd) : _process2.default.cwd();
  const normalizedSources = normalizeSources(_optionalChain([options, 'optionalAccess', _3 => _3.sources]), cwd);
  const { Scanner } = await importOxide();
  const scanner = new Scanner({
    sources: normalizedSources
  });
  const files = _nullishCoalesce(scanner.files, () => ( []));
  const entries = [];
  const skipped = [];
  for (const file of files) {
    let content;
    try {
      content = await _fs.promises.readFile(file, "utf8");
    } catch (error) {
      skipped.push({
        file,
        reason: error instanceof Error ? error.message : "Unknown error"
      });
      continue;
    }
    const extension = toExtension(file);
    const matches = scanner.getCandidatesWithPositions({
      file,
      content,
      extension
    });
    if (!matches.length) {
      continue;
    }
    const offsets = buildLineOffsets(content);
    const relativeFile = toRelativeFile(cwd, file);
    for (const match of matches) {
      const info = resolveLineMeta(content, offsets, match.position);
      entries.push({
        rawCandidate: match.candidate,
        file,
        relativeFile,
        extension,
        start: match.position,
        end: match.position + match.candidate.length,
        length: match.candidate.length,
        line: info.line,
        column: info.column,
        lineText: info.lineText
      });
    }
  }
  return {
    entries,
    filesScanned: files.length,
    skippedFiles: skipped,
    sources: normalizedSources
  };
}
function groupTokensByFile(report, options) {
  const key = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _4 => _4.key]), () => ( "relative"));
  const stripAbsolute = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _5 => _5.stripAbsolutePaths]), () => ( key !== "absolute"));
  return report.entries.reduce((acc, entry) => {
    const bucketKey = key === "absolute" ? entry.file : entry.relativeFile;
    if (!acc[bucketKey]) {
      acc[bucketKey] = [];
    }
    const value = stripAbsolute ? {
      ...entry,
      file: entry.relativeFile
    } : entry;
    acc[bucketKey].push(value);
    return acc;
  }, {});
}

// src/options/normalize.ts



// src/constants.ts
var pkgName = "tailwindcss-patch";

// src/options/normalize.ts
function toPrettyValue(value) {
  if (typeof value === "number") {
    return value > 0 ? value : false;
  }
  if (value === true) {
    return 2;
  }
  return false;
}
function normalizeCacheOptions(cache, projectRoot) {
  let enabled = false;
  let cwd = projectRoot;
  let dir = _pathe2.default.resolve(cwd, "node_modules/.cache", pkgName);
  let file = "class-cache.json";
  let strategy = "merge";
  if (typeof cache === "boolean") {
    enabled = cache;
  } else if (typeof cache === "object" && cache) {
    enabled = _nullishCoalesce(cache.enabled, () => ( true));
    cwd = _nullishCoalesce(cache.cwd, () => ( cwd));
    dir = cache.dir ? _pathe2.default.resolve(cache.dir) : _pathe2.default.resolve(cwd, "node_modules/.cache", pkgName);
    file = _nullishCoalesce(cache.file, () => ( file));
    strategy = _nullishCoalesce(cache.strategy, () => ( strategy));
  }
  const filename = _pathe2.default.resolve(dir, file);
  return {
    enabled,
    cwd,
    dir,
    file,
    path: filename,
    strategy
  };
}
function normalizeOutputOptions(output) {
  const enabled = _nullishCoalesce(_optionalChain([output, 'optionalAccess', _6 => _6.enabled]), () => ( true));
  const file = _nullishCoalesce(_optionalChain([output, 'optionalAccess', _7 => _7.file]), () => ( ".tw-patch/tw-class-list.json"));
  const format = _nullishCoalesce(_optionalChain([output, 'optionalAccess', _8 => _8.format]), () => ( "json"));
  const pretty = toPrettyValue(_nullishCoalesce(_optionalChain([output, 'optionalAccess', _9 => _9.pretty]), () => ( true)));
  const removeUniversalSelector = _nullishCoalesce(_optionalChain([output, 'optionalAccess', _10 => _10.removeUniversalSelector]), () => ( true));
  return {
    enabled,
    file,
    format,
    pretty,
    removeUniversalSelector
  };
}
function normalizeExposeContextOptions(features) {
  if (_optionalChain([features, 'optionalAccess', _11 => _11.exposeContext]) === false) {
    return {
      enabled: false,
      refProperty: "contextRef"
    };
  }
  if (typeof _optionalChain([features, 'optionalAccess', _12 => _12.exposeContext]) === "object" && features.exposeContext) {
    return {
      enabled: true,
      refProperty: _nullishCoalesce(features.exposeContext.refProperty, () => ( "contextRef"))
    };
  }
  return {
    enabled: true,
    refProperty: "contextRef"
  };
}
function normalizeExtendLengthUnitsOptions(features) {
  const extend = _optionalChain([features, 'optionalAccess', _13 => _13.extendLengthUnits]);
  if (extend === false || extend === void 0) {
    return null;
  }
  if (extend.enabled === false) {
    return null;
  }
  const base = {
    units: ["rpx"],
    overwrite: true
  };
  return {
    ...base,
    ...extend,
    enabled: _nullishCoalesce(extend.enabled, () => ( true)),
    units: _nullishCoalesce(extend.units, () => ( base.units)),
    overwrite: _nullishCoalesce(extend.overwrite, () => ( base.overwrite))
  };
}
function normalizeTailwindV4Options(v4, fallbackBase) {
  const configuredBase = _optionalChain([v4, 'optionalAccess', _14 => _14.base]) ? _pathe2.default.resolve(v4.base) : void 0;
  const base = _nullishCoalesce(configuredBase, () => ( fallbackBase));
  const cssEntries = Array.isArray(_optionalChain([v4, 'optionalAccess', _15 => _15.cssEntries])) ? v4.cssEntries.filter((entry) => Boolean(entry)).map((entry) => _pathe2.default.resolve(entry)) : [];
  const userSources = _optionalChain([v4, 'optionalAccess', _16 => _16.sources]);
  const hasUserDefinedSources = Boolean(_optionalChain([userSources, 'optionalAccess', _17 => _17.length]));
  const sources = hasUserDefinedSources ? userSources : [
    {
      base: fallbackBase,
      pattern: "**/*",
      negated: false
    }
  ];
  return {
    base,
    configuredBase,
    css: _optionalChain([v4, 'optionalAccess', _18 => _18.css]),
    cssEntries,
    sources,
    hasUserDefinedSources
  };
}
function normalizeTailwindOptions(tailwind, projectRoot) {
  const packageName = _nullishCoalesce(_optionalChain([tailwind, 'optionalAccess', _19 => _19.packageName]), () => ( "tailwindcss"));
  const versionHint = _optionalChain([tailwind, 'optionalAccess', _20 => _20.version]);
  const resolve = _optionalChain([tailwind, 'optionalAccess', _21 => _21.resolve]);
  const cwd = _nullishCoalesce(_optionalChain([tailwind, 'optionalAccess', _22 => _22.cwd]), () => ( projectRoot));
  const config = _optionalChain([tailwind, 'optionalAccess', _23 => _23.config]);
  const postcssPlugin = _optionalChain([tailwind, 'optionalAccess', _24 => _24.postcssPlugin]);
  const v4 = normalizeTailwindV4Options(_optionalChain([tailwind, 'optionalAccess', _25 => _25.v4]), cwd);
  return {
    packageName,
    versionHint,
    resolve,
    cwd,
    config,
    postcssPlugin,
    v2: _optionalChain([tailwind, 'optionalAccess', _26 => _26.v2]),
    v3: _optionalChain([tailwind, 'optionalAccess', _27 => _27.v3]),
    v4
  };
}
function normalizeOptions(options = {}) {
  const projectRoot = options.cwd ? _pathe2.default.resolve(options.cwd) : _process2.default.cwd();
  const overwrite = _nullishCoalesce(options.overwrite, () => ( true));
  const output = normalizeOutputOptions(options.output);
  const cache = normalizeCacheOptions(options.cache, projectRoot);
  const tailwind = normalizeTailwindOptions(options.tailwind, projectRoot);
  const exposeContext = normalizeExposeContextOptions(options.features);
  const extendLengthUnits = normalizeExtendLengthUnitsOptions(options.features);
  const filter = (className) => {
    if (output.removeUniversalSelector && className === "*") {
      return false;
    }
    if (typeof options.filter === "function") {
      return options.filter(className) !== false;
    }
    return true;
  };
  return {
    projectRoot,
    overwrite,
    tailwind,
    features: {
      exposeContext,
      extendLengthUnits
    },
    output,
    cache,
    filter
  };
}

// src/runtime/class-collector.ts




// src/utils.ts
function isObject(val) {
  return val !== null && typeof val === "object" && Array.isArray(val) === false;
}
function spliceChangesIntoString(str, changes) {
  if (!changes[0]) {
    return str;
  }
  changes.sort((a, b) => {
    return a.end - b.end || a.start - b.start;
  });
  let result = "";
  let previous = changes[0];
  result += str.slice(0, previous.start);
  result += previous.replacement;
  for (let i = 1; i < changes.length; ++i) {
    const change = changes[i];
    result += str.slice(previous.end, change.start);
    result += change.replacement;
    previous = change;
  }
  result += str.slice(previous.end);
  return result;
}

// src/runtime/class-collector.ts
function collectClassesFromContexts(contexts, filter) {
  const set = /* @__PURE__ */ new Set();
  for (const context of contexts) {
    if (!isObject(context) || !context.classCache) {
      continue;
    }
    for (const key of context.classCache.keys()) {
      const className = key.toString();
      if (filter(className)) {
        set.add(className);
      }
    }
  }
  return set;
}
async function collectClassesFromTailwindV4(options) {
  const set = /* @__PURE__ */ new Set();
  const v4Options = options.tailwind.v4;
  if (!v4Options) {
    return set;
  }
  const toAbsolute = (value) => {
    if (!value) {
      return void 0;
    }
    return _pathe2.default.isAbsolute(value) ? value : _pathe2.default.resolve(options.projectRoot, value);
  };
  const resolvedConfiguredBase = toAbsolute(v4Options.configuredBase);
  const resolvedDefaultBase = _nullishCoalesce(toAbsolute(v4Options.base), () => ( _process2.default.cwd()));
  const resolveSources = (base) => {
    if (!_optionalChain([v4Options, 'access', _28 => _28.sources, 'optionalAccess', _29 => _29.length])) {
      return void 0;
    }
    return v4Options.sources.map((source) => ({
      base: _nullishCoalesce(source.base, () => ( base)),
      pattern: source.pattern,
      negated: source.negated
    }));
  };
  if (v4Options.cssEntries.length > 0) {
    for (const entry of v4Options.cssEntries) {
      const filePath = _pathe2.default.isAbsolute(entry) ? entry : _pathe2.default.resolve(options.projectRoot, entry);
      if (!await _fsextra2.default.pathExists(filePath)) {
        continue;
      }
      const css = await _fsextra2.default.readFile(filePath, "utf8");
      const entryDir = _pathe2.default.dirname(filePath);
      const baseForEntry = _nullishCoalesce(resolvedConfiguredBase, () => ( entryDir));
      const sources = resolveSources(baseForEntry);
      const candidates = await extractValidCandidates({
        cwd: options.projectRoot,
        base: baseForEntry,
        css,
        sources
      });
      for (const candidate of candidates) {
        if (options.filter(candidate)) {
          set.add(candidate);
        }
      }
    }
  } else {
    const baseForCss = _nullishCoalesce(resolvedConfiguredBase, () => ( resolvedDefaultBase));
    const sources = resolveSources(baseForCss);
    const candidates = await extractValidCandidates({
      cwd: options.projectRoot,
      base: baseForCss,
      css: v4Options.css,
      sources
    });
    for (const candidate of candidates) {
      if (options.filter(candidate)) {
        set.add(candidate);
      }
    }
  }
  return set;
}

// src/runtime/context-registry.ts
var _module = require('module');


var require2 = _module.createRequire.call(void 0, importMetaUrl);
function resolveRuntimeEntry(packageInfo, majorVersion) {
  const root = packageInfo.rootPath;
  if (majorVersion === 2) {
    const jitIndex = _pathe2.default.join(root, "lib/jit/index.js");
    if (_fsextra2.default.existsSync(jitIndex)) {
      return jitIndex;
    }
  } else if (majorVersion === 3) {
    const plugin = _pathe2.default.join(root, "lib/plugin.js");
    const index = _pathe2.default.join(root, "lib/index.js");
    if (_fsextra2.default.existsSync(plugin)) {
      return plugin;
    }
    if (_fsextra2.default.existsSync(index)) {
      return index;
    }
  }
  return void 0;
}
function loadRuntimeContexts(packageInfo, majorVersion, refProperty) {
  if (majorVersion === 4) {
    return [];
  }
  const entry = resolveRuntimeEntry(packageInfo, majorVersion);
  if (!entry) {
    return [];
  }
  const moduleExports = require2(entry);
  if (!moduleExports) {
    return [];
  }
  const ref = moduleExports[refProperty];
  if (!ref) {
    return [];
  }
  if (Array.isArray(ref)) {
    return ref;
  }
  if (typeof ref === "object" && Array.isArray(ref.value)) {
    return ref.value;
  }
  return [];
}

// src/runtime/process-tailwindcss.ts


var _postcss = require('postcss'); var _postcss2 = _interopRequireDefault(_postcss);
var _tailwindcssconfig = require('tailwindcss-config');
var require3 = _module.createRequire.call(void 0, importMetaUrl);
async function resolveConfigPath(options) {
  if (options.config && _pathe2.default.isAbsolute(options.config)) {
    return options.config;
  }
  const result = await _tailwindcssconfig.loadConfig.call(void 0, { cwd: options.cwd });
  if (!result) {
    throw new Error(`Unable to locate Tailwind CSS config from ${options.cwd}`);
  }
  return result.filepath;
}
async function runTailwindBuild(options) {
  const configPath = await resolveConfigPath(options);
  const pluginName = _nullishCoalesce(options.postcssPlugin, () => ( (options.majorVersion === 4 ? "@tailwindcss/postcss" : "tailwindcss")));
  if (options.majorVersion === 4) {
    return _postcss2.default.call(void 0, [
      require3(pluginName)({
        config: configPath
      })
    ]).process("@import 'tailwindcss';", {
      from: void 0
    });
  }
  return _postcss2.default.call(void 0, [
    require3(pluginName)({
      config: configPath
    })
  ]).process("@tailwind base;@tailwind components;@tailwind utilities;", {
    from: void 0
  });
}

// src/api/tailwindcss-patcher.ts


var _localpkg = require('local-pkg');

var _semver = require('semver');

// src/options/legacy.ts
function normalizeLegacyFeatures(patch) {
  const apply = _optionalChain([patch, 'optionalAccess', _30 => _30.applyPatches]);
  const extend = _optionalChain([apply, 'optionalAccess', _31 => _31.extendLengthUnits]);
  let extendOption = false;
  if (extend && typeof extend === "object") {
    extendOption = {
      ...extend,
      enabled: true
    };
  } else if (extend === true) {
    extendOption = {
      enabled: true,
      units: ["rpx"],
      overwrite: _optionalChain([patch, 'optionalAccess', _32 => _32.overwrite])
    };
  }
  return {
    exposeContext: _nullishCoalesce(_optionalChain([apply, 'optionalAccess', _33 => _33.exportContext]), () => ( true)),
    extendLengthUnits: extendOption
  };
}
function fromLegacyOptions(options) {
  if (!options) {
    return {};
  }
  const patch = options.patch;
  const features = normalizeLegacyFeatures(patch);
  const output = _optionalChain([patch, 'optionalAccess', _34 => _34.output]);
  const tailwindConfig = _optionalChain([patch, 'optionalAccess', _35 => _35.tailwindcss]);
  const tailwindVersion = _optionalChain([tailwindConfig, 'optionalAccess', _36 => _36.version]);
  const tailwindV2 = _optionalChain([tailwindConfig, 'optionalAccess', _37 => _37.v2]);
  const tailwindV3 = _optionalChain([tailwindConfig, 'optionalAccess', _38 => _38.v3]);
  const tailwindV4 = _optionalChain([tailwindConfig, 'optionalAccess', _39 => _39.v4]);
  const tailwindConfigPath = _nullishCoalesce(_optionalChain([tailwindV3, 'optionalAccess', _40 => _40.config]), () => ( _optionalChain([tailwindV2, 'optionalAccess', _41 => _41.config])));
  const tailwindCwd = _nullishCoalesce(_nullishCoalesce(_optionalChain([tailwindV3, 'optionalAccess', _42 => _42.cwd]), () => ( _optionalChain([tailwindV2, 'optionalAccess', _43 => _43.cwd]))), () => ( _optionalChain([patch, 'optionalAccess', _44 => _44.cwd])));
  return {
    cwd: _optionalChain([patch, 'optionalAccess', _45 => _45.cwd]),
    overwrite: _optionalChain([patch, 'optionalAccess', _46 => _46.overwrite]),
    filter: _optionalChain([patch, 'optionalAccess', _47 => _47.filter]),
    cache: typeof options.cache === "boolean" ? options.cache : options.cache ? {
      ...options.cache,
      enabled: _nullishCoalesce(options.cache.enabled, () => ( true))
    } : void 0,
    output: output ? {
      file: output.filename,
      pretty: output.loose ? 2 : false,
      removeUniversalSelector: output.removeUniversalSelector
    } : void 0,
    tailwind: {
      packageName: _optionalChain([patch, 'optionalAccess', _48 => _48.packageName]),
      version: tailwindVersion,
      resolve: _optionalChain([patch, 'optionalAccess', _49 => _49.resolve]),
      config: tailwindConfigPath,
      cwd: tailwindCwd,
      v2: tailwindV2,
      v3: tailwindV3,
      v4: tailwindV4
    },
    features: {
      exposeContext: features.exposeContext,
      extendLengthUnits: features.extendLengthUnits
    }
  };
}
function fromUnifiedConfig(registry) {
  if (!registry) {
    return {};
  }
  const tailwind = registry.tailwind;
  const output = registry.output;
  const pretty = (() => {
    if (_optionalChain([output, 'optionalAccess', _50 => _50.pretty]) === void 0) {
      return void 0;
    }
    if (typeof output.pretty === "boolean") {
      return output.pretty ? 2 : false;
    }
    return output.pretty;
  })();
  return {
    output: output ? {
      file: output.file,
      pretty,
      removeUniversalSelector: output.stripUniversalSelector
    } : void 0,
    tailwind: tailwind ? {
      version: tailwind.version,
      packageName: tailwind.package,
      resolve: tailwind.resolve,
      config: tailwind.config,
      cwd: tailwind.cwd,
      v2: tailwind.legacy,
      v3: tailwind.classic,
      v4: tailwind.next
    } : void 0
  };
}

// src/patching/operations/export-context/index.ts



// src/patching/operations/export-context/postcss-v2.ts
var _types = require('@babel/types'); var t = _interopRequireWildcard(_types); var t2 = _interopRequireWildcard(_types); var t3 = _interopRequireWildcard(_types);

// src/babel/index.ts
var _generator = require('@babel/generator'); var _generator2 = _interopRequireDefault(_generator);
var _traverse = require('@babel/traverse'); var _traverse2 = _interopRequireDefault(_traverse);
var _parser = require('@babel/parser');
function _interopDefaultCompat(e) {
  return e && typeof e === "object" && "default" in e ? e.default : e;
}
var generate = _interopDefaultCompat(_generator2.default);
var traverse = _interopDefaultCompat(_traverse2.default);

// src/patching/operations/export-context/postcss-v2.ts
var IDENTIFIER_RE = /^[A-Z_$][\w$]*$/i;
function toIdentifierName(property) {
  if (!property) {
    return "contextRef";
  }
  const sanitized = property.replace(/[^\w$]/gu, "_");
  if (/^\d/.test(sanitized)) {
    return `_${sanitized}`;
  }
  return sanitized || "contextRef";
}
function createExportsMember(property) {
  if (IDENTIFIER_RE.test(property)) {
    return t.memberExpression(t.identifier("exports"), t.identifier(property));
  }
  return t.memberExpression(t.identifier("exports"), t.stringLiteral(property), true);
}
function transformProcessTailwindFeaturesReturnContextV2(content) {
  const ast = _parser.parse.call(void 0, content, {
    sourceType: "unambiguous"
  });
  let hasPatched = false;
  traverse(ast, {
    FunctionDeclaration(path10) {
      const node = path10.node;
      if (_optionalChain([node, 'access', _51 => _51.id, 'optionalAccess', _52 => _52.name]) !== "processTailwindFeatures" || node.body.body.length !== 1 || !t.isReturnStatement(node.body.body[0])) {
        return;
      }
      const returnStatement3 = node.body.body[0];
      if (!t.isFunctionExpression(returnStatement3.argument)) {
        return;
      }
      const body = returnStatement3.argument.body.body;
      const lastStatement = body[body.length - 1];
      const alreadyReturnsContext = Boolean(
        t.isReturnStatement(lastStatement) && t.isIdentifier(lastStatement.argument) && lastStatement.argument.name === "context"
      );
      hasPatched = alreadyReturnsContext;
      if (!alreadyReturnsContext) {
        body.push(t.returnStatement(t.identifier("context")));
      }
    }
  });
  return {
    code: hasPatched ? content : generate(ast).code,
    hasPatched
  };
}
function transformPostcssPluginV2(content, options) {
  const refIdentifier = t.identifier(toIdentifierName(options.refProperty));
  const exportMember = createExportsMember(options.refProperty);
  const valueMember = t.memberExpression(refIdentifier, t.identifier("value"));
  const ast = _parser.parse.call(void 0, content);
  let hasPatched = false;
  traverse(ast, {
    Program(path10) {
      const program = path10.node;
      const index = program.body.findIndex((statement) => {
        return t.isFunctionDeclaration(statement) && _optionalChain([statement, 'access', _53 => _53.id, 'optionalAccess', _54 => _54.name]) === "_default";
      });
      if (index === -1) {
        return;
      }
      const previous = program.body[index - 1];
      const beforePrevious = program.body[index - 2];
      const alreadyHasVariable = Boolean(
        previous && t.isVariableDeclaration(previous) && previous.declarations.length === 1 && t.isIdentifier(previous.declarations[0].id) && previous.declarations[0].id.name === refIdentifier.name
      );
      const alreadyAssignsExports = Boolean(
        beforePrevious && t.isExpressionStatement(beforePrevious) && t.isAssignmentExpression(beforePrevious.expression) && t.isMemberExpression(beforePrevious.expression.left) && t.isIdentifier(beforePrevious.expression.right) && beforePrevious.expression.right.name === refIdentifier.name && generate(beforePrevious.expression.left).code === generate(exportMember).code
      );
      hasPatched = alreadyHasVariable && alreadyAssignsExports;
      if (!alreadyHasVariable) {
        program.body.splice(
          index,
          0,
          t.variableDeclaration("var", [
            t.variableDeclarator(
              refIdentifier,
              t.objectExpression([
                t.objectProperty(t.identifier("value"), t.arrayExpression())
              ])
            )
          ]),
          t.expressionStatement(
            t.assignmentExpression("=", exportMember, refIdentifier)
          )
        );
      }
    },
    FunctionDeclaration(path10) {
      if (hasPatched) {
        return;
      }
      const fn = path10.node;
      if (_optionalChain([fn, 'access', _55 => _55.id, 'optionalAccess', _56 => _56.name]) !== "_default") {
        return;
      }
      if (fn.body.body.length !== 1 || !t.isReturnStatement(fn.body.body[0])) {
        return;
      }
      const returnStatement3 = fn.body.body[0];
      if (!t.isCallExpression(returnStatement3.argument) || !t.isMemberExpression(returnStatement3.argument.callee) || !t.isArrayExpression(returnStatement3.argument.callee.object)) {
        return;
      }
      const fnExpression = returnStatement3.argument.callee.object.elements[1];
      if (!fnExpression || !t.isFunctionExpression(fnExpression)) {
        return;
      }
      const block = fnExpression.body;
      const statements = block.body;
      if (t.isExpressionStatement(statements[0]) && t.isAssignmentExpression(statements[0].expression) && t.isNumericLiteral(statements[0].expression.right)) {
        hasPatched = true;
        return;
      }
      const lastStatement = statements[statements.length - 1];
      if (lastStatement && t.isExpressionStatement(lastStatement)) {
        statements[statements.length - 1] = t.expressionStatement(
          t.callExpression(
            t.memberExpression(valueMember, t.identifier("push")),
            [lastStatement.expression]
          )
        );
      }
      const index = statements.findIndex((statement) => t.isIfStatement(statement));
      if (index > -1) {
        const ifStatement = statements[index];
        if (t.isBlockStatement(ifStatement.consequent) && ifStatement.consequent.body[1] && t.isForOfStatement(ifStatement.consequent.body[1])) {
          const forOf = ifStatement.consequent.body[1];
          if (t.isBlockStatement(forOf.body) && forOf.body.body.length === 1) {
            const nestedIf = forOf.body.body[0];
            if (nestedIf && t.isIfStatement(nestedIf) && t.isBlockStatement(nestedIf.consequent) && nestedIf.consequent.body.length === 1 && t.isExpressionStatement(nestedIf.consequent.body[0])) {
              nestedIf.consequent.body[0] = t.expressionStatement(
                t.callExpression(
                  t.memberExpression(valueMember, t.identifier("push")),
                  [nestedIf.consequent.body[0].expression]
                )
              );
            }
          }
        }
      }
      statements.unshift(
        t.expressionStatement(
          t.assignmentExpression(
            "=",
            t.memberExpression(valueMember, t.identifier("length")),
            t.numericLiteral(0)
          )
        )
      );
    }
  });
  return {
    code: hasPatched ? content : generate(ast).code,
    hasPatched
  };
}

// src/patching/operations/export-context/postcss-v3.ts

var IDENTIFIER_RE2 = /^[A-Z_$][\w$]*$/i;
function toIdentifierName2(property) {
  if (!property) {
    return "contextRef";
  }
  const sanitized = property.replace(/[^\w$]/gu, "_");
  if (/^\d/.test(sanitized)) {
    return `_${sanitized}`;
  }
  return sanitized || "contextRef";
}
function createModuleExportsMember(property) {
  const object = t2.memberExpression(t2.identifier("module"), t2.identifier("exports"));
  if (IDENTIFIER_RE2.test(property)) {
    return t2.memberExpression(object, t2.identifier(property));
  }
  return t2.memberExpression(object, t2.stringLiteral(property), true);
}
function transformProcessTailwindFeaturesReturnContext(content) {
  const ast = _parser.parse.call(void 0, content);
  let hasPatched = false;
  traverse(ast, {
    FunctionDeclaration(path10) {
      const node = path10.node;
      if (_optionalChain([node, 'access', _57 => _57.id, 'optionalAccess', _58 => _58.name]) !== "processTailwindFeatures" || node.body.body.length !== 1) {
        return;
      }
      const [returnStatement3] = node.body.body;
      if (!t2.isReturnStatement(returnStatement3) || !t2.isFunctionExpression(returnStatement3.argument)) {
        return;
      }
      const expression = returnStatement3.argument;
      const body = expression.body.body;
      const lastStatement = body[body.length - 1];
      const alreadyReturnsContext = Boolean(
        t2.isReturnStatement(lastStatement) && t2.isIdentifier(lastStatement.argument) && lastStatement.argument.name === "context"
      );
      hasPatched = alreadyReturnsContext;
      if (!alreadyReturnsContext) {
        body.push(t2.returnStatement(t2.identifier("context")));
      }
    }
  });
  return {
    code: hasPatched ? content : generate(ast).code,
    hasPatched
  };
}
function transformPostcssPlugin(content, { refProperty }) {
  const ast = _parser.parse.call(void 0, content);
  const refIdentifier = t2.identifier(toIdentifierName2(refProperty));
  const moduleExportsMember = createModuleExportsMember(refProperty);
  const valueMember = t2.memberExpression(refIdentifier, t2.identifier("value"));
  let hasPatched = false;
  traverse(ast, {
    Program(path10) {
      const program = path10.node;
      const index = program.body.findIndex((statement) => {
        return t2.isExpressionStatement(statement) && t2.isAssignmentExpression(statement.expression) && t2.isMemberExpression(statement.expression.left) && t2.isFunctionExpression(statement.expression.right) && _optionalChain([statement, 'access', _59 => _59.expression, 'access', _60 => _60.right, 'access', _61 => _61.id, 'optionalAccess', _62 => _62.name]) === "tailwindcss";
      });
      if (index === -1) {
        return;
      }
      const previousStatement = program.body[index - 1];
      const lastStatement = program.body[program.body.length - 1];
      const alreadyHasVariable = Boolean(
        previousStatement && t2.isVariableDeclaration(previousStatement) && previousStatement.declarations.length === 1 && t2.isIdentifier(previousStatement.declarations[0].id) && previousStatement.declarations[0].id.name === refIdentifier.name
      );
      const alreadyAssignsModuleExports = Boolean(
        t2.isExpressionStatement(lastStatement) && t2.isAssignmentExpression(lastStatement.expression) && t2.isMemberExpression(lastStatement.expression.left) && t2.isIdentifier(lastStatement.expression.right) && lastStatement.expression.right.name === refIdentifier.name && generate(lastStatement.expression.left).code === generate(moduleExportsMember).code
      );
      hasPatched = alreadyHasVariable && alreadyAssignsModuleExports;
      if (!alreadyHasVariable) {
        program.body.splice(
          index,
          0,
          t2.variableDeclaration("const", [
            t2.variableDeclarator(
              refIdentifier,
              t2.objectExpression([
                t2.objectProperty(t2.identifier("value"), t2.arrayExpression())
              ])
            )
          ])
        );
      }
      if (!alreadyAssignsModuleExports) {
        program.body.push(
          t2.expressionStatement(
            t2.assignmentExpression("=", moduleExportsMember, refIdentifier)
          )
        );
      }
    },
    FunctionExpression(path10) {
      if (hasPatched) {
        return;
      }
      const fn = path10.node;
      if (_optionalChain([fn, 'access', _63 => _63.id, 'optionalAccess', _64 => _64.name]) !== "tailwindcss" || fn.body.body.length !== 1) {
        return;
      }
      const [returnStatement3] = fn.body.body;
      if (!returnStatement3 || !t2.isReturnStatement(returnStatement3) || !t2.isObjectExpression(returnStatement3.argument)) {
        return;
      }
      const properties = returnStatement3.argument.properties;
      if (properties.length !== 2) {
        return;
      }
      const pluginsProperty = properties.find(
        (prop) => t2.isObjectProperty(prop) && t2.isIdentifier(prop.key) && prop.key.name === "plugins"
      );
      if (!pluginsProperty || !t2.isObjectProperty(pluginsProperty) || !t2.isCallExpression(pluginsProperty.value) || !t2.isMemberExpression(pluginsProperty.value.callee) || !t2.isArrayExpression(pluginsProperty.value.callee.object)) {
        return;
      }
      const pluginsArray = pluginsProperty.value.callee.object.elements;
      const targetPlugin = pluginsArray[1];
      if (!targetPlugin || !t2.isFunctionExpression(targetPlugin)) {
        return;
      }
      const block = targetPlugin.body;
      const statements = block.body;
      const last = statements[statements.length - 1];
      if (last && t2.isExpressionStatement(last)) {
        statements[statements.length - 1] = t2.expressionStatement(
          t2.callExpression(
            t2.memberExpression(valueMember, t2.identifier("push")),
            [last.expression]
          )
        );
      }
      const index = statements.findIndex((s) => t2.isIfStatement(s));
      if (index > -1) {
        const ifStatement = statements[index];
        if (t2.isBlockStatement(ifStatement.consequent)) {
          const [, second] = ifStatement.consequent.body;
          if (second && t2.isForOfStatement(second) && t2.isBlockStatement(second.body)) {
            const bodyStatement = second.body.body[0];
            if (bodyStatement && t2.isIfStatement(bodyStatement) && t2.isBlockStatement(bodyStatement.consequent) && bodyStatement.consequent.body.length === 1 && t2.isExpressionStatement(bodyStatement.consequent.body[0])) {
              bodyStatement.consequent.body[0] = t2.expressionStatement(
                t2.callExpression(
                  t2.memberExpression(valueMember, t2.identifier("push")),
                  [bodyStatement.consequent.body[0].expression]
                )
              );
            }
          }
        }
      }
      statements.unshift(
        t2.expressionStatement(
          t2.assignmentExpression(
            "=",
            t2.memberExpression(valueMember, t2.identifier("length")),
            t2.numericLiteral(0)
          )
        )
      );
    }
  });
  return {
    code: hasPatched ? content : generate(ast).code,
    hasPatched
  };
}

// src/patching/operations/export-context/index.ts
function writeFileIfRequired(filePath, code, overwrite, successMessage) {
  if (!overwrite) {
    return;
  }
  _fsextra2.default.writeFileSync(filePath, code, {
    encoding: "utf8"
  });
  logger_default.success(successMessage);
}
function applyExposeContextPatch(params) {
  const { rootDir, refProperty, overwrite, majorVersion } = params;
  const result = {
    applied: false,
    files: {}
  };
  if (majorVersion === 3) {
    const processFileRelative = "lib/processTailwindFeatures.js";
    const processFilePath = _pathe2.default.resolve(rootDir, processFileRelative);
    if (_fsextra2.default.existsSync(processFilePath)) {
      const content = _fsextra2.default.readFileSync(processFilePath, "utf8");
      const { code, hasPatched } = transformProcessTailwindFeaturesReturnContext(content);
      result.files[processFileRelative] = code;
      if (!hasPatched) {
        writeFileIfRequired(
          processFilePath,
          code,
          overwrite,
          "Patched Tailwind CSS processTailwindFeatures to expose runtime context."
        );
        result.applied = true;
      }
    }
    const pluginCandidates = ["lib/plugin.js", "lib/index.js"];
    const pluginRelative = pluginCandidates.find((candidate) => _fsextra2.default.existsSync(_pathe2.default.resolve(rootDir, candidate)));
    if (pluginRelative) {
      const pluginPath = _pathe2.default.resolve(rootDir, pluginRelative);
      const content = _fsextra2.default.readFileSync(pluginPath, "utf8");
      const { code, hasPatched } = transformPostcssPlugin(content, { refProperty });
      result.files[pluginRelative] = code;
      if (!hasPatched) {
        writeFileIfRequired(
          pluginPath,
          code,
          overwrite,
          "Patched Tailwind CSS plugin entry to collect runtime contexts."
        );
        result.applied = true;
      }
    }
  } else if (majorVersion === 2) {
    const processFileRelative = "lib/jit/processTailwindFeatures.js";
    const processFilePath = _pathe2.default.resolve(rootDir, processFileRelative);
    if (_fsextra2.default.existsSync(processFilePath)) {
      const content = _fsextra2.default.readFileSync(processFilePath, "utf8");
      const { code, hasPatched } = transformProcessTailwindFeaturesReturnContextV2(content);
      result.files[processFileRelative] = code;
      if (!hasPatched) {
        writeFileIfRequired(
          processFilePath,
          code,
          overwrite,
          "Patched Tailwind CSS JIT processTailwindFeatures to expose runtime context."
        );
        result.applied = true;
      }
    }
    const pluginRelative = "lib/jit/index.js";
    const pluginPath = _pathe2.default.resolve(rootDir, pluginRelative);
    if (_fsextra2.default.existsSync(pluginPath)) {
      const content = _fsextra2.default.readFileSync(pluginPath, "utf8");
      const { code, hasPatched } = transformPostcssPluginV2(content, { refProperty });
      result.files[pluginRelative] = code;
      if (!hasPatched) {
        writeFileIfRequired(
          pluginPath,
          code,
          overwrite,
          "Patched Tailwind CSS JIT entry to collect runtime contexts."
        );
        result.applied = true;
      }
    }
  }
  return result;
}

// src/patching/operations/extend-length-units.ts



function updateLengthUnitsArray(content, options) {
  const { variableName = "lengthUnits", units } = options;
  const ast = _parser.parse.call(void 0, content);
  let arrayRef;
  let changed = false;
  traverse(ast, {
    Identifier(path10) {
      if (path10.node.name === variableName && t3.isVariableDeclarator(path10.parent) && t3.isArrayExpression(path10.parent.init)) {
        arrayRef = path10.parent.init;
        const existing = new Set(
          path10.parent.init.elements.map((element) => t3.isStringLiteral(element) ? element.value : void 0).filter(Boolean)
        );
        for (const unit of units) {
          if (!existing.has(unit)) {
            path10.parent.init.elements = path10.parent.init.elements.map((element) => {
              if (t3.isStringLiteral(element)) {
                return t3.stringLiteral(element.value);
              }
              return element;
            });
            path10.parent.init.elements.push(t3.stringLiteral(unit));
            changed = true;
          }
        }
      }
    }
  });
  return {
    arrayRef,
    changed
  };
}
function applyExtendLengthUnitsPatchV3(rootDir, options) {
  if (!options.enabled) {
    return { changed: false, code: void 0 };
  }
  const opts = {
    ...options,
    lengthUnitsFilePath: _nullishCoalesce(options.lengthUnitsFilePath, () => ( "lib/util/dataTypes.js")),
    variableName: _nullishCoalesce(options.variableName, () => ( "lengthUnits"))
  };
  const dataTypesFilePath = _pathe2.default.resolve(rootDir, opts.lengthUnitsFilePath);
  const exists = _fsextra2.default.existsSync(dataTypesFilePath);
  if (!exists) {
    return { changed: false, code: void 0 };
  }
  const content = _fsextra2.default.readFileSync(dataTypesFilePath, "utf8");
  const { arrayRef, changed } = updateLengthUnitsArray(content, opts);
  if (!arrayRef || !changed) {
    return { changed: false, code: void 0 };
  }
  const { code } = generate(arrayRef, {
    jsescOption: { quotes: "single" }
  });
  if (arrayRef.start != null && arrayRef.end != null) {
    const nextCode = `${content.slice(0, arrayRef.start)}${code}${content.slice(arrayRef.end)}`;
    if (opts.overwrite) {
      const target = opts.destPath ? _pathe2.default.resolve(opts.destPath) : dataTypesFilePath;
      _fsextra2.default.writeFileSync(target, nextCode, "utf8");
      logger_default.success("Patched Tailwind CSS length unit list (v3).");
    }
    return {
      changed: true,
      code: nextCode
    };
  }
  return {
    changed: false,
    code: void 0
  };
}
function applyExtendLengthUnitsPatchV4(rootDir, options) {
  if (!options.enabled) {
    return { files: [], changed: false };
  }
  const opts = { ...options };
  const distDir = _pathe2.default.resolve(rootDir, "dist");
  if (!_fsextra2.default.existsSync(distDir)) {
    return { files: [], changed: false };
  }
  const entries = _fsextra2.default.readdirSync(distDir);
  const chunkNames = entries.filter((entry) => entry.endsWith(".js") || entry.endsWith(".mjs"));
  const pattern = /\[\s*["']cm["'],\s*["']mm["'],[\w,"']+\]/;
  const candidates = chunkNames.map((chunkName) => {
    const file = _pathe2.default.join(distDir, chunkName);
    const code = _fsextra2.default.readFileSync(file, "utf8");
    const match = pattern.exec(code);
    if (!match) {
      return null;
    }
    return {
      file,
      code,
      match,
      hasPatched: false
    };
  }).filter((candidate) => candidate !== null);
  for (const item of candidates) {
    const { code, file, match } = item;
    const ast = _parser.parse.call(void 0, match[0], { sourceType: "unambiguous" });
    traverse(ast, {
      ArrayExpression(path10) {
        for (const unit of opts.units) {
          if (path10.node.elements.some((element) => t3.isStringLiteral(element) && element.value === unit)) {
            item.hasPatched = true;
            return;
          }
          path10.node.elements.push(t3.stringLiteral(unit));
        }
      }
    });
    if (item.hasPatched) {
      continue;
    }
    const { code: replacement } = generate(ast, { minified: true });
    const start = _nullishCoalesce(match.index, () => ( 0));
    const end = start + match[0].length;
    item.code = spliceChangesIntoString(code, [
      {
        start,
        end,
        replacement: replacement.endsWith(";") ? replacement.slice(0, -1) : replacement
      }
    ]);
    if (opts.overwrite) {
      _fsextra2.default.writeFileSync(file, item.code, "utf8");
    }
  }
  if (candidates.some((file) => !file.hasPatched)) {
    logger_default.success("Patched Tailwind CSS length unit list (v4).");
  }
  return {
    changed: candidates.some((file) => !file.hasPatched),
    files: candidates
  };
}

// src/patching/patch-runner.ts
function applyTailwindPatches(context) {
  const { packageInfo, options, majorVersion } = context;
  const results = {};
  if (options.features.exposeContext.enabled && (majorVersion === 2 || majorVersion === 3)) {
    results.exposeContext = applyExposeContextPatch({
      rootDir: packageInfo.rootPath,
      refProperty: options.features.exposeContext.refProperty,
      overwrite: options.overwrite,
      majorVersion
    });
  }
  if (_optionalChain([options, 'access', _65 => _65.features, 'access', _66 => _66.extendLengthUnits, 'optionalAccess', _67 => _67.enabled])) {
    if (majorVersion === 3) {
      results.extendLengthUnits = applyExtendLengthUnitsPatchV3(
        packageInfo.rootPath,
        options.features.extendLengthUnits
      );
    } else if (majorVersion === 4) {
      results.extendLengthUnits = applyExtendLengthUnitsPatchV4(
        packageInfo.rootPath,
        options.features.extendLengthUnits
      );
    }
  }
  return results;
}

// src/api/tailwindcss-patcher.ts
function resolveMajorVersion(version, hint) {
  if (hint && [2, 3, 4].includes(hint)) {
    return hint;
  }
  if (version) {
    const coerced = _semver.coerce.call(void 0, version);
    if (coerced) {
      const major = coerced.major;
      if (major === 2 || major === 3 || major === 4) {
        return major;
      }
      if (major >= 4) {
        return 4;
      }
    }
  }
  return 3;
}
function resolveTailwindExecutionOptions(normalized, majorVersion) {
  const base = normalized.tailwind;
  if (majorVersion === 2 && base.v2) {
    return {
      cwd: _nullishCoalesce(_nullishCoalesce(base.v2.cwd, () => ( base.cwd)), () => ( normalized.projectRoot)),
      config: _nullishCoalesce(base.v2.config, () => ( base.config)),
      postcssPlugin: _nullishCoalesce(base.v2.postcssPlugin, () => ( base.postcssPlugin))
    };
  }
  if (majorVersion === 3 && base.v3) {
    return {
      cwd: _nullishCoalesce(_nullishCoalesce(base.v3.cwd, () => ( base.cwd)), () => ( normalized.projectRoot)),
      config: _nullishCoalesce(base.v3.config, () => ( base.config)),
      postcssPlugin: _nullishCoalesce(base.v3.postcssPlugin, () => ( base.postcssPlugin))
    };
  }
  return {
    cwd: _nullishCoalesce(base.cwd, () => ( normalized.projectRoot)),
    config: base.config,
    postcssPlugin: base.postcssPlugin
  };
}
var TailwindcssPatcher = (_class = class {
  
  
  
  
  constructor(options = {}) {;_class.prototype.__init.call(this);
    const resolvedOptions = options && typeof options === "object" && "patch" in options ? fromLegacyOptions(options) : options;
    this.options = normalizeOptions(resolvedOptions);
    const packageInfo = _localpkg.getPackageInfoSync.call(void 0, 
      this.options.tailwind.packageName,
      this.options.tailwind.resolve
    );
    if (!packageInfo) {
      throw new Error(`Unable to locate Tailwind CSS package "${this.options.tailwind.packageName}".`);
    }
    this.packageInfo = packageInfo;
    this.majorVersion = resolveMajorVersion(
      this.packageInfo.version,
      this.options.tailwind.versionHint
    );
    this.cacheStore = new CacheStore(this.options.cache);
  }
  async patch() {
    return applyTailwindPatches({
      packageInfo: this.packageInfo,
      options: this.options,
      majorVersion: this.majorVersion
    });
  }
  getContexts() {
    return loadRuntimeContexts(
      this.packageInfo,
      this.majorVersion,
      this.options.features.exposeContext.refProperty
    );
  }
  async runTailwindBuildIfNeeded() {
    if (this.majorVersion === 2 || this.majorVersion === 3) {
      const executionOptions = resolveTailwindExecutionOptions(this.options, this.majorVersion);
      await runTailwindBuild({
        cwd: executionOptions.cwd,
        config: executionOptions.config,
        majorVersion: this.majorVersion,
        postcssPlugin: executionOptions.postcssPlugin
      });
    }
  }
  async collectClassSet() {
    if (this.majorVersion === 4) {
      return collectClassesFromTailwindV4(this.options);
    }
    const contexts = this.getContexts();
    return collectClassesFromContexts(contexts, this.options.filter);
  }
  async mergeWithCache(set) {
    if (!this.options.cache.enabled) {
      return set;
    }
    const existing = await this.cacheStore.read();
    if (this.options.cache.strategy === "merge") {
      for (const value of existing) {
        set.add(value);
      }
      await this.cacheStore.write(set);
    } else {
      if (set.size > 0) {
        await this.cacheStore.write(set);
      } else {
        return existing;
      }
    }
    return set;
  }
  mergeWithCacheSync(set) {
    if (!this.options.cache.enabled) {
      return set;
    }
    const existing = this.cacheStore.readSync();
    if (this.options.cache.strategy === "merge") {
      for (const value of existing) {
        set.add(value);
      }
      this.cacheStore.writeSync(set);
    } else {
      if (set.size > 0) {
        this.cacheStore.writeSync(set);
      } else {
        return existing;
      }
    }
    return set;
  }
  async getClassSet() {
    await this.runTailwindBuildIfNeeded();
    const set = await this.collectClassSet();
    return this.mergeWithCache(set);
  }
  getClassSetSync() {
    if (this.majorVersion === 4) {
      throw new Error("getClassSetSync is not supported for Tailwind CSS v4 projects. Use getClassSet instead.");
    }
    const contexts = this.getContexts();
    const set = collectClassesFromContexts(contexts, this.options.filter);
    const merged = this.mergeWithCacheSync(set);
    if (contexts.length === 0 && merged.size === 0) {
      return void 0;
    }
    return merged;
  }
  async extract(options) {
    const shouldWrite = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _68 => _68.write]), () => ( this.options.output.enabled));
    const classSet = await this.getClassSet();
    const classList = Array.from(classSet);
    const result = {
      classList,
      classSet
    };
    if (!shouldWrite || !this.options.output.file) {
      return result;
    }
    const target = _pathe2.default.resolve(this.options.output.file);
    await _fsextra2.default.ensureDir(_pathe2.default.dirname(target));
    if (this.options.output.format === "json") {
      const spaces = typeof this.options.output.pretty === "number" ? this.options.output.pretty : void 0;
      await _fsextra2.default.writeJSON(target, classList, { spaces });
    } else {
      await _fsextra2.default.writeFile(target, `${classList.join("\n")}
`, "utf8");
    }
    logger_default.success(`Tailwind CSS class list saved to ${target.replace(_process2.default.cwd(), ".")}`);
    return {
      ...result,
      filename: target
    };
  }
  // Backwards compatibility helper used by tests and API consumers.
  __init() {this.extractValidCandidates = exports.extractValidCandidates = extractValidCandidates}
  async collectContentTokens(options) {
    return extractProjectCandidatesWithPositions({
      cwd: _nullishCoalesce(_optionalChain([options, 'optionalAccess', _69 => _69.cwd]), () => ( this.options.projectRoot)),
      sources: _nullishCoalesce(_nullishCoalesce(_optionalChain([options, 'optionalAccess', _70 => _70.sources]), () => ( _optionalChain([this, 'access', _71 => _71.options, 'access', _72 => _72.tailwind, 'access', _73 => _73.v4, 'optionalAccess', _74 => _74.sources]))), () => ( []))
    });
  }
  async collectContentTokensByFile(options) {
    const report = await this.collectContentTokens({
      cwd: _optionalChain([options, 'optionalAccess', _75 => _75.cwd]),
      sources: _optionalChain([options, 'optionalAccess', _76 => _76.sources])
    });
    return groupTokensByFile(report, {
      key: _optionalChain([options, 'optionalAccess', _77 => _77.key]),
      stripAbsolutePaths: _optionalChain([options, 'optionalAccess', _78 => _78.stripAbsolutePaths])
    });
  }
}, _class);

// src/cli/commands.ts

var _config = require('@tailwindcss-mangle/config');

// ../../node_modules/.pnpm/defu@6.1.4/node_modules/defu/dist/defu.mjs
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject(value) && isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
var defu = createDefu();
var defuFn = createDefu((object, key, currentValue) => {
  if (object[key] !== void 0 && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});
var defuArrayFn = createDefu((object, key, currentValue) => {
  if (Array.isArray(object[key]) && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});

// ../shared/src/utils.ts
var defuOverrideArray = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = value;
    return true;
  }
});
var preserveClassNames = [
  // https://tailwindcss.com/docs/transition-timing-function start
  // https://github.com/sonofmagic/tailwindcss-mangle/issues/21
  "ease-out",
  "ease-linear",
  "ease-in",
  "ease-in-out"
  // https://tailwindcss.com/docs/transition-timing-function end
];
var preserveClassNamesMap = preserveClassNames.reduce((acc, cur) => {
  acc[cur] = true;
  return acc;
}, {});
var acceptChars = [..."abcdefghijklmnopqrstuvwxyz"];

// src/cli/commands.ts
var _cac = require('cac'); var _cac2 = _interopRequireDefault(_cac);


var tailwindcssPatchCommands = ["install", "extract", "tokens", "init"];
var TOKEN_FORMATS = ["json", "lines", "grouped-json"];
var DEFAULT_TOKEN_REPORT = ".tw-patch/tw-token-report.json";
function formatTokenLine(entry) {
  return `${entry.relativeFile}:${entry.line}:${entry.column} ${entry.rawCandidate} (${entry.start}-${entry.end})`;
}
function formatGroupedPreview(map, limit = 3) {
  const files = Object.keys(map);
  if (!files.length) {
    return { preview: "", moreFiles: 0 };
  }
  const lines = files.slice(0, limit).map((file) => {
    const tokens = map[file];
    const sample = tokens.slice(0, 3).map((token) => token.rawCandidate).join(", ");
    const suffix = tokens.length > 3 ? ", \u2026" : "";
    return `${file}: ${tokens.length} tokens (${sample}${suffix})`;
  });
  return {
    preview: lines.join("\n"),
    moreFiles: Math.max(0, files.length - limit)
  };
}
function resolveCwd(rawCwd) {
  if (!rawCwd) {
    return _process2.default.cwd();
  }
  return _pathe2.default.resolve(rawCwd);
}
function createDefaultRunner(factory) {
  let promise;
  return () => {
    if (!promise) {
      promise = factory();
    }
    return promise;
  };
}
async function loadPatchOptionsForCwd(cwd, overrides) {
  const { config } = await _config.getConfig.call(void 0, cwd);
  const legacyConfig = config;
  const base = _optionalChain([config, 'optionalAccess', _79 => _79.registry]) ? fromUnifiedConfig(config.registry) : _optionalChain([legacyConfig, 'optionalAccess', _80 => _80.patch]) ? fromLegacyOptions({ patch: legacyConfig.patch }) : {};
  const merged = defu(_nullishCoalesce(overrides, () => ( {})), base);
  return merged;
}
function createCommandContext(cli, command, commandName, args, cwd) {
  let cachedOptions;
  let cachedPatcher;
  let cachedConfig;
  const loadPatchOptionsForContext = (overrides) => {
    if (overrides) {
      return loadPatchOptionsForCwd(cwd, overrides);
    }
    if (!cachedOptions) {
      cachedOptions = loadPatchOptionsForCwd(cwd);
    }
    return cachedOptions;
  };
  const createPatcherForContext = async (overrides) => {
    if (overrides) {
      const patchOptions = await loadPatchOptionsForCwd(cwd, overrides);
      return new TailwindcssPatcher(patchOptions);
    }
    if (!cachedPatcher) {
      cachedPatcher = loadPatchOptionsForContext().then((options) => new TailwindcssPatcher(options));
    }
    return cachedPatcher;
  };
  return {
    cli,
    command,
    commandName,
    args,
    cwd,
    logger: logger_default,
    loadConfig: () => {
      if (!cachedConfig) {
        cachedConfig = _config.getConfig.call(void 0, cwd);
      }
      return cachedConfig;
    },
    loadPatchOptions: loadPatchOptionsForContext,
    createPatcher: createPatcherForContext
  };
}
function createCwdOptionDefinition(description = "Working directory") {
  return {
    flags: "--cwd <dir>",
    description,
    config: { default: _process2.default.cwd() }
  };
}
function buildDefaultCommandDefinitions() {
  return {
    install: {
      description: "Apply Tailwind CSS runtime patches",
      optionDefs: [createCwdOptionDefinition()]
    },
    extract: {
      description: "Collect generated class names into a cache file",
      optionDefs: [
        createCwdOptionDefinition(),
        { flags: "--output <file>", description: "Override output file path" },
        { flags: "--format <format>", description: "Output format (json|lines)" },
        { flags: "--css <file>", description: "Tailwind CSS entry CSS when using v4" },
        { flags: "--no-write", description: "Skip writing to disk" }
      ]
    },
    tokens: {
      description: "Extract Tailwind tokens with file/position metadata",
      optionDefs: [
        createCwdOptionDefinition(),
        { flags: "--output <file>", description: "Override output file path", config: { default: DEFAULT_TOKEN_REPORT } },
        {
          flags: "--format <format>",
          description: "Output format (json|lines|grouped-json)",
          config: { default: "json" }
        },
        {
          flags: "--group-key <key>",
          description: "Grouping key for grouped-json output (relative|absolute)",
          config: { default: "relative" }
        },
        { flags: "--no-write", description: "Skip writing to disk" }
      ]
    },
    init: {
      description: "Generate a tailwindcss-patch config file",
      optionDefs: [createCwdOptionDefinition()]
    }
  };
}
function addPrefixIfMissing(value, prefix) {
  if (!prefix || value.startsWith(prefix)) {
    return value;
  }
  return `${prefix}${value}`;
}
function resolveCommandNames(command, mountOptions, prefix) {
  const override = _optionalChain([mountOptions, 'access', _81 => _81.commandOptions, 'optionalAccess', _82 => _82[command]]);
  const baseName = _nullishCoalesce(_optionalChain([override, 'optionalAccess', _83 => _83.name]), () => ( command));
  const name = addPrefixIfMissing(baseName, prefix);
  const aliases = (_nullishCoalesce(_optionalChain([override, 'optionalAccess', _84 => _84.aliases]), () => ( []))).map((alias) => addPrefixIfMissing(alias, prefix));
  return { name, aliases };
}
function resolveOptionDefinitions(defaults, override) {
  if (!override) {
    return defaults;
  }
  const appendDefaults = _nullishCoalesce(override.appendDefaultOptions, () => ( true));
  const customDefs = _nullishCoalesce(override.optionDefs, () => ( []));
  if (!appendDefaults) {
    return customDefs;
  }
  if (customDefs.length === 0) {
    return defaults;
  }
  return [...defaults, ...customDefs];
}
function applyCommandOptions(command, optionDefs) {
  for (const option of optionDefs) {
    command.option(option.flags, _nullishCoalesce(option.description, () => ( "")), option.config);
  }
}
function runWithCommandHandler(cli, command, commandName, args, handler, defaultHandler) {
  const cwd = resolveCwd(args.cwd);
  const context = createCommandContext(cli, command, commandName, args, cwd);
  const runDefault = createDefaultRunner(() => defaultHandler(context));
  if (!handler) {
    return runDefault();
  }
  return handler(context, runDefault);
}
function resolveCommandMetadata(command, mountOptions, prefix, defaults) {
  const names = resolveCommandNames(command, mountOptions, prefix);
  const definition = defaults[command];
  const override = _optionalChain([mountOptions, 'access', _85 => _85.commandOptions, 'optionalAccess', _86 => _86[command]]);
  const description = _nullishCoalesce(_optionalChain([override, 'optionalAccess', _87 => _87.description]), () => ( definition.description));
  const optionDefs = resolveOptionDefinitions(definition.optionDefs, override);
  return { ...names, description, optionDefs };
}
async function installCommandDefaultHandler(ctx) {
  const patcher = await ctx.createPatcher();
  await patcher.patch();
  logger_default.success("Tailwind CSS runtime patched successfully.");
}
async function extractCommandDefaultHandler(ctx) {
  const { args } = ctx;
  const overrides = {};
  let hasOverrides = false;
  if (args.output || args.format) {
    overrides.output = {
      file: args.output,
      format: args.format
    };
    hasOverrides = true;
  }
  if (args.css) {
    overrides.tailwind = {
      v4: {
        cssEntries: [args.css]
      }
    };
    hasOverrides = true;
  }
  const patcher = await ctx.createPatcher(hasOverrides ? overrides : void 0);
  const result = await patcher.extract({ write: args.write });
  if (result.filename) {
    logger_default.success(`Collected ${result.classList.length} classes \u2192 ${result.filename}`);
  } else {
    logger_default.success(`Collected ${result.classList.length} classes.`);
  }
  return result;
}
async function tokensCommandDefaultHandler(ctx) {
  const { args } = ctx;
  const patcher = await ctx.createPatcher();
  const report = await patcher.collectContentTokens();
  const shouldWrite = _nullishCoalesce(args.write, () => ( true));
  let format = _nullishCoalesce(args.format, () => ( "json"));
  if (!TOKEN_FORMATS.includes(format)) {
    format = "json";
  }
  const targetFile = _nullishCoalesce(args.output, () => ( DEFAULT_TOKEN_REPORT));
  const groupKey = args.groupKey === "absolute" ? "absolute" : "relative";
  const buildGrouped = () => groupTokensByFile(report, {
    key: groupKey,
    stripAbsolutePaths: groupKey !== "absolute"
  });
  const grouped = format === "grouped-json" ? buildGrouped() : null;
  const resolveGrouped = () => _nullishCoalesce(grouped, () => ( buildGrouped()));
  if (shouldWrite) {
    const target = _pathe2.default.resolve(targetFile);
    await _fsextra2.default.ensureDir(_pathe2.default.dirname(target));
    if (format === "json") {
      await _fsextra2.default.writeJSON(target, report, { spaces: 2 });
    } else if (format === "grouped-json") {
      await _fsextra2.default.writeJSON(target, resolveGrouped(), { spaces: 2 });
    } else {
      const lines = report.entries.map(formatTokenLine);
      await _fsextra2.default.writeFile(target, `${lines.join("\n")}
`, "utf8");
    }
    logger_default.success(`Collected ${report.entries.length} tokens (${format}) \u2192 ${target.replace(_process2.default.cwd(), ".")}`);
  } else {
    logger_default.success(`Collected ${report.entries.length} tokens from ${report.filesScanned} files.`);
    if (format === "lines") {
      const preview = report.entries.slice(0, 5).map(formatTokenLine).join("\n");
      if (preview) {
        logger_default.log("");
        logger_default.info(preview);
        if (report.entries.length > 5) {
          logger_default.info(`\u2026and ${report.entries.length - 5} more.`);
        }
      }
    } else if (format === "grouped-json") {
      const map = resolveGrouped();
      const { preview, moreFiles } = formatGroupedPreview(map);
      if (preview) {
        logger_default.log("");
        logger_default.info(preview);
        if (moreFiles > 0) {
          logger_default.info(`\u2026and ${moreFiles} more files.`);
        }
      }
    } else {
      const previewEntries = report.entries.slice(0, 3);
      if (previewEntries.length) {
        logger_default.log("");
        logger_default.info(JSON.stringify(previewEntries, null, 2));
      }
    }
  }
  if (report.skippedFiles.length) {
    logger_default.warn("Skipped files:");
    for (const skipped of report.skippedFiles) {
      logger_default.warn(`  \u2022 ${skipped.file} (${skipped.reason})`);
    }
  }
  return report;
}
async function initCommandDefaultHandler(ctx) {
  await _config.initConfig.call(void 0, ctx.cwd);
  logger_default.success(`\u2728 ${_config.CONFIG_NAME}.config.ts initialized!`);
}
function mountTailwindcssPatchCommands(cli, options = {}) {
  const prefix = _nullishCoalesce(options.commandPrefix, () => ( ""));
  const selectedCommands = _nullishCoalesce(options.commands, () => ( tailwindcssPatchCommands));
  const defaultDefinitions = buildDefaultCommandDefinitions();
  const registrars = {
    install: () => {
      const metadata = resolveCommandMetadata("install", options, prefix, defaultDefinitions);
      const command = cli.command(metadata.name, metadata.description);
      applyCommandOptions(command, metadata.optionDefs);
      command.action(async (args) => {
        return runWithCommandHandler(
          cli,
          command,
          "install",
          args,
          _optionalChain([options, 'access', _88 => _88.commandHandlers, 'optionalAccess', _89 => _89.install]),
          installCommandDefaultHandler
        );
      });
      metadata.aliases.forEach((alias) => command.alias(alias));
    },
    extract: () => {
      const metadata = resolveCommandMetadata("extract", options, prefix, defaultDefinitions);
      const command = cli.command(metadata.name, metadata.description);
      applyCommandOptions(command, metadata.optionDefs);
      command.action(async (args) => {
        return runWithCommandHandler(
          cli,
          command,
          "extract",
          args,
          _optionalChain([options, 'access', _90 => _90.commandHandlers, 'optionalAccess', _91 => _91.extract]),
          extractCommandDefaultHandler
        );
      });
      metadata.aliases.forEach((alias) => command.alias(alias));
    },
    tokens: () => {
      const metadata = resolveCommandMetadata("tokens", options, prefix, defaultDefinitions);
      const command = cli.command(metadata.name, metadata.description);
      applyCommandOptions(command, metadata.optionDefs);
      command.action(async (args) => {
        return runWithCommandHandler(
          cli,
          command,
          "tokens",
          args,
          _optionalChain([options, 'access', _92 => _92.commandHandlers, 'optionalAccess', _93 => _93.tokens]),
          tokensCommandDefaultHandler
        );
      });
      metadata.aliases.forEach((alias) => command.alias(alias));
    },
    init: () => {
      const metadata = resolveCommandMetadata("init", options, prefix, defaultDefinitions);
      const command = cli.command(metadata.name, metadata.description);
      applyCommandOptions(command, metadata.optionDefs);
      command.action(async (args) => {
        return runWithCommandHandler(
          cli,
          command,
          "init",
          args,
          _optionalChain([options, 'access', _94 => _94.commandHandlers, 'optionalAccess', _95 => _95.init]),
          initCommandDefaultHandler
        );
      });
      metadata.aliases.forEach((alias) => command.alias(alias));
    }
  };
  for (const name of selectedCommands) {
    const register = registrars[name];
    if (register) {
      register();
    }
  }
  return cli;
}
function createTailwindcssPatchCli(options = {}) {
  const cli = _cac2.default.call(void 0, _nullishCoalesce(options.name, () => ( "tw-patch")));
  mountTailwindcssPatchCommands(cli, options.mountOptions);
  return cli;
}


















exports.logger_default = logger_default; exports.CacheStore = CacheStore; exports.extractRawCandidatesWithPositions = extractRawCandidatesWithPositions; exports.extractRawCandidates = extractRawCandidates; exports.extractValidCandidates = extractValidCandidates; exports.extractProjectCandidatesWithPositions = extractProjectCandidatesWithPositions; exports.groupTokensByFile = groupTokensByFile; exports.normalizeOptions = normalizeOptions; exports.collectClassesFromContexts = collectClassesFromContexts; exports.collectClassesFromTailwindV4 = collectClassesFromTailwindV4; exports.loadRuntimeContexts = loadRuntimeContexts; exports.runTailwindBuild = runTailwindBuild; exports.TailwindcssPatcher = TailwindcssPatcher; exports.tailwindcssPatchCommands = tailwindcssPatchCommands; exports.mountTailwindcssPatchCommands = mountTailwindcssPatchCommands; exports.createTailwindcssPatchCli = createTailwindcssPatchCli;
