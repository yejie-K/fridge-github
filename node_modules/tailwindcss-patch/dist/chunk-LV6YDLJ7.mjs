// src/logger.ts
import { createConsola } from "consola";
var logger = createConsola();
var logger_default = logger;

// src/cache/store.ts
import process from "process";
import fs from "fs-extra";
function isErrnoException(error) {
  return error instanceof Error && typeof error.code === "string";
}
var CacheStore = class {
  constructor(options) {
    this.options = options;
  }
  async ensureDir() {
    await fs.ensureDir(this.options.dir);
  }
  ensureDirSync() {
    fs.ensureDirSync(this.options.dir);
  }
  createTempPath() {
    const uniqueSuffix = `${process.pid}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
    return `${this.options.path}.${uniqueSuffix}.tmp`;
  }
  async replaceCacheFile(tempPath) {
    try {
      await fs.rename(tempPath, this.options.path);
    } catch (error) {
      if (isErrnoException(error) && (error.code === "EEXIST" || error.code === "EPERM")) {
        try {
          await fs.remove(this.options.path);
        } catch (removeError) {
          if (!isErrnoException(removeError) || removeError.code !== "ENOENT") {
            throw removeError;
          }
        }
        await fs.rename(tempPath, this.options.path);
        return;
      }
      throw error;
    }
  }
  replaceCacheFileSync(tempPath) {
    try {
      fs.renameSync(tempPath, this.options.path);
    } catch (error) {
      if (isErrnoException(error) && (error.code === "EEXIST" || error.code === "EPERM")) {
        try {
          fs.removeSync(this.options.path);
        } catch (removeError) {
          if (!isErrnoException(removeError) || removeError.code !== "ENOENT") {
            throw removeError;
          }
        }
        fs.renameSync(tempPath, this.options.path);
        return;
      }
      throw error;
    }
  }
  async cleanupTempFile(tempPath) {
    try {
      await fs.remove(tempPath);
    } catch {
    }
  }
  cleanupTempFileSync(tempPath) {
    try {
      fs.removeSync(tempPath);
    } catch {
    }
  }
  async write(data) {
    if (!this.options.enabled) {
      return void 0;
    }
    const tempPath = this.createTempPath();
    try {
      await this.ensureDir();
      await fs.writeJSON(tempPath, Array.from(data));
      await this.replaceCacheFile(tempPath);
      return this.options.path;
    } catch (error) {
      await this.cleanupTempFile(tempPath);
      logger_default.error("Unable to persist Tailwind class cache", error);
      return void 0;
    }
  }
  writeSync(data) {
    if (!this.options.enabled) {
      return void 0;
    }
    const tempPath = this.createTempPath();
    try {
      this.ensureDirSync();
      fs.writeJSONSync(tempPath, Array.from(data));
      this.replaceCacheFileSync(tempPath);
      return this.options.path;
    } catch (error) {
      this.cleanupTempFileSync(tempPath);
      logger_default.error("Unable to persist Tailwind class cache", error);
      return void 0;
    }
  }
  async read() {
    if (!this.options.enabled) {
      return /* @__PURE__ */ new Set();
    }
    try {
      const exists = await fs.pathExists(this.options.path);
      if (!exists) {
        return /* @__PURE__ */ new Set();
      }
      const data = await fs.readJSON(this.options.path);
      if (Array.isArray(data)) {
        return new Set(data.filter((item) => typeof item === "string"));
      }
    } catch (error) {
      if (isErrnoException(error) && error.code === "ENOENT") {
        return /* @__PURE__ */ new Set();
      }
      logger_default.warn("Unable to read Tailwind class cache, removing invalid file.", error);
      try {
        await fs.remove(this.options.path);
      } catch (cleanupError) {
        logger_default.error("Failed to clean up invalid cache file", cleanupError);
      }
    }
    return /* @__PURE__ */ new Set();
  }
  readSync() {
    if (!this.options.enabled) {
      return /* @__PURE__ */ new Set();
    }
    try {
      const exists = fs.pathExistsSync(this.options.path);
      if (!exists) {
        return /* @__PURE__ */ new Set();
      }
      const data = fs.readJSONSync(this.options.path);
      if (Array.isArray(data)) {
        return new Set(data.filter((item) => typeof item === "string"));
      }
    } catch (error) {
      if (isErrnoException(error) && error.code === "ENOENT") {
        return /* @__PURE__ */ new Set();
      }
      logger_default.warn("Unable to read Tailwind class cache, removing invalid file.", error);
      try {
        fs.removeSync(this.options.path);
      } catch (cleanupError) {
        logger_default.error("Failed to clean up invalid cache file", cleanupError);
      }
    }
    return /* @__PURE__ */ new Set();
  }
};

// src/extraction/candidate-extractor.ts
import { promises as fs2 } from "fs";
import process2 from "process";
import path from "pathe";
async function importNode() {
  return import("@tailwindcss/node");
}
async function importOxide() {
  return import("@tailwindcss/oxide");
}
async function extractRawCandidatesWithPositions(content, extension = "html") {
  const { Scanner } = await importOxide();
  const scanner = new Scanner({});
  const result = scanner.getCandidatesWithPositions({ content, extension });
  return result.map(({ candidate, position }) => ({
    rawCandidate: candidate,
    start: position,
    end: position + candidate.length
  }));
}
async function extractRawCandidates(sources) {
  const { Scanner } = await importOxide();
  const scanner = new Scanner({
    sources
  });
  return scanner.scan();
}
async function extractValidCandidates(options) {
  const providedOptions = options ?? {};
  const defaultCwd = providedOptions.cwd ?? process2.cwd();
  const base = providedOptions.base ?? defaultCwd;
  const css = providedOptions.css ?? '@import "tailwindcss";';
  const sources = (providedOptions.sources ?? [
    {
      base: defaultCwd,
      pattern: "**/*",
      negated: false
    }
  ]).map((source) => ({
    base: source.base ?? defaultCwd,
    pattern: source.pattern,
    negated: source.negated
  }));
  const { __unstable__loadDesignSystem } = await importNode();
  const designSystem = await __unstable__loadDesignSystem(css, { base });
  const candidates = await extractRawCandidates(sources);
  const parsedCandidates = candidates.filter(
    (rawCandidate) => designSystem.parseCandidate(rawCandidate).length > 0
  );
  if (parsedCandidates.length === 0) {
    return parsedCandidates;
  }
  const cssByCandidate = designSystem.candidatesToCss(parsedCandidates);
  const validCandidates = [];
  for (let index = 0; index < parsedCandidates.length; index++) {
    const css2 = cssByCandidate[index];
    if (typeof css2 === "string" && css2.trim().length > 0) {
      validCandidates.push(parsedCandidates[index]);
    }
  }
  return validCandidates;
}
function normalizeSources(sources, cwd) {
  const baseSources = sources?.length ? sources : [
    {
      base: cwd,
      pattern: "**/*",
      negated: false
    }
  ];
  return baseSources.map((source) => ({
    base: source.base ?? cwd,
    pattern: source.pattern,
    negated: source.negated
  }));
}
function buildLineOffsets(content) {
  const offsets = [0];
  for (let i = 0; i < content.length; i++) {
    if (content[i] === "\n") {
      offsets.push(i + 1);
    }
  }
  if (offsets[offsets.length - 1] !== content.length) {
    offsets.push(content.length);
  }
  return offsets;
}
function resolveLineMeta(content, offsets, index) {
  let low = 0;
  let high = offsets.length - 1;
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    const start = offsets[mid];
    const nextStart = offsets[mid + 1] ?? content.length;
    if (index < start) {
      high = mid - 1;
      continue;
    }
    if (index >= nextStart) {
      low = mid + 1;
      continue;
    }
    const line = mid + 1;
    const column = index - start + 1;
    const lineEnd = content.indexOf("\n", start);
    const lineText = content.slice(start, lineEnd === -1 ? content.length : lineEnd);
    return { line, column, lineText };
  }
  const lastStart = offsets[offsets.length - 2] ?? 0;
  return {
    line: offsets.length - 1,
    column: index - lastStart + 1,
    lineText: content.slice(lastStart)
  };
}
function toExtension(filename) {
  const ext = path.extname(filename).replace(/^\./, "");
  return ext || "txt";
}
function toRelativeFile(cwd, filename) {
  const relative = path.relative(cwd, filename);
  return relative === "" ? path.basename(filename) : relative;
}
async function extractProjectCandidatesWithPositions(options) {
  const cwd = options?.cwd ? path.resolve(options.cwd) : process2.cwd();
  const normalizedSources = normalizeSources(options?.sources, cwd);
  const { Scanner } = await importOxide();
  const scanner = new Scanner({
    sources: normalizedSources
  });
  const files = scanner.files ?? [];
  const entries = [];
  const skipped = [];
  for (const file of files) {
    let content;
    try {
      content = await fs2.readFile(file, "utf8");
    } catch (error) {
      skipped.push({
        file,
        reason: error instanceof Error ? error.message : "Unknown error"
      });
      continue;
    }
    const extension = toExtension(file);
    const matches = scanner.getCandidatesWithPositions({
      file,
      content,
      extension
    });
    if (!matches.length) {
      continue;
    }
    const offsets = buildLineOffsets(content);
    const relativeFile = toRelativeFile(cwd, file);
    for (const match of matches) {
      const info = resolveLineMeta(content, offsets, match.position);
      entries.push({
        rawCandidate: match.candidate,
        file,
        relativeFile,
        extension,
        start: match.position,
        end: match.position + match.candidate.length,
        length: match.candidate.length,
        line: info.line,
        column: info.column,
        lineText: info.lineText
      });
    }
  }
  return {
    entries,
    filesScanned: files.length,
    skippedFiles: skipped,
    sources: normalizedSources
  };
}
function groupTokensByFile(report, options) {
  const key = options?.key ?? "relative";
  const stripAbsolute = options?.stripAbsolutePaths ?? key !== "absolute";
  return report.entries.reduce((acc, entry) => {
    const bucketKey = key === "absolute" ? entry.file : entry.relativeFile;
    if (!acc[bucketKey]) {
      acc[bucketKey] = [];
    }
    const value = stripAbsolute ? {
      ...entry,
      file: entry.relativeFile
    } : entry;
    acc[bucketKey].push(value);
    return acc;
  }, {});
}

// src/options/normalize.ts
import process3 from "process";
import path2 from "pathe";

// src/constants.ts
var pkgName = "tailwindcss-patch";

// src/options/normalize.ts
function toPrettyValue(value) {
  if (typeof value === "number") {
    return value > 0 ? value : false;
  }
  if (value === true) {
    return 2;
  }
  return false;
}
function normalizeCacheOptions(cache, projectRoot) {
  let enabled = false;
  let cwd = projectRoot;
  let dir = path2.resolve(cwd, "node_modules/.cache", pkgName);
  let file = "class-cache.json";
  let strategy = "merge";
  if (typeof cache === "boolean") {
    enabled = cache;
  } else if (typeof cache === "object" && cache) {
    enabled = cache.enabled ?? true;
    cwd = cache.cwd ?? cwd;
    dir = cache.dir ? path2.resolve(cache.dir) : path2.resolve(cwd, "node_modules/.cache", pkgName);
    file = cache.file ?? file;
    strategy = cache.strategy ?? strategy;
  }
  const filename = path2.resolve(dir, file);
  return {
    enabled,
    cwd,
    dir,
    file,
    path: filename,
    strategy
  };
}
function normalizeOutputOptions(output) {
  const enabled = output?.enabled ?? true;
  const file = output?.file ?? ".tw-patch/tw-class-list.json";
  const format = output?.format ?? "json";
  const pretty = toPrettyValue(output?.pretty ?? true);
  const removeUniversalSelector = output?.removeUniversalSelector ?? true;
  return {
    enabled,
    file,
    format,
    pretty,
    removeUniversalSelector
  };
}
function normalizeExposeContextOptions(features) {
  if (features?.exposeContext === false) {
    return {
      enabled: false,
      refProperty: "contextRef"
    };
  }
  if (typeof features?.exposeContext === "object" && features.exposeContext) {
    return {
      enabled: true,
      refProperty: features.exposeContext.refProperty ?? "contextRef"
    };
  }
  return {
    enabled: true,
    refProperty: "contextRef"
  };
}
function normalizeExtendLengthUnitsOptions(features) {
  const extend = features?.extendLengthUnits;
  if (extend === false || extend === void 0) {
    return null;
  }
  if (extend.enabled === false) {
    return null;
  }
  const base = {
    units: ["rpx"],
    overwrite: true
  };
  return {
    ...base,
    ...extend,
    enabled: extend.enabled ?? true,
    units: extend.units ?? base.units,
    overwrite: extend.overwrite ?? base.overwrite
  };
}
function normalizeTailwindV4Options(v4, fallbackBase) {
  const configuredBase = v4?.base ? path2.resolve(v4.base) : void 0;
  const base = configuredBase ?? fallbackBase;
  const cssEntries = Array.isArray(v4?.cssEntries) ? v4.cssEntries.filter((entry) => Boolean(entry)).map((entry) => path2.resolve(entry)) : [];
  const userSources = v4?.sources;
  const hasUserDefinedSources = Boolean(userSources?.length);
  const sources = hasUserDefinedSources ? userSources : [
    {
      base: fallbackBase,
      pattern: "**/*",
      negated: false
    }
  ];
  return {
    base,
    configuredBase,
    css: v4?.css,
    cssEntries,
    sources,
    hasUserDefinedSources
  };
}
function normalizeTailwindOptions(tailwind, projectRoot) {
  const packageName = tailwind?.packageName ?? "tailwindcss";
  const versionHint = tailwind?.version;
  const resolve = tailwind?.resolve;
  const cwd = tailwind?.cwd ?? projectRoot;
  const config = tailwind?.config;
  const postcssPlugin = tailwind?.postcssPlugin;
  const v4 = normalizeTailwindV4Options(tailwind?.v4, cwd);
  return {
    packageName,
    versionHint,
    resolve,
    cwd,
    config,
    postcssPlugin,
    v2: tailwind?.v2,
    v3: tailwind?.v3,
    v4
  };
}
function normalizeOptions(options = {}) {
  const projectRoot = options.cwd ? path2.resolve(options.cwd) : process3.cwd();
  const overwrite = options.overwrite ?? true;
  const output = normalizeOutputOptions(options.output);
  const cache = normalizeCacheOptions(options.cache, projectRoot);
  const tailwind = normalizeTailwindOptions(options.tailwind, projectRoot);
  const exposeContext = normalizeExposeContextOptions(options.features);
  const extendLengthUnits = normalizeExtendLengthUnitsOptions(options.features);
  const filter = (className) => {
    if (output.removeUniversalSelector && className === "*") {
      return false;
    }
    if (typeof options.filter === "function") {
      return options.filter(className) !== false;
    }
    return true;
  };
  return {
    projectRoot,
    overwrite,
    tailwind,
    features: {
      exposeContext,
      extendLengthUnits
    },
    output,
    cache,
    filter
  };
}

// src/runtime/class-collector.ts
import process4 from "process";
import fs3 from "fs-extra";
import path3 from "pathe";

// src/utils.ts
function isObject(val) {
  return val !== null && typeof val === "object" && Array.isArray(val) === false;
}
function spliceChangesIntoString(str, changes) {
  if (!changes[0]) {
    return str;
  }
  changes.sort((a, b) => {
    return a.end - b.end || a.start - b.start;
  });
  let result = "";
  let previous = changes[0];
  result += str.slice(0, previous.start);
  result += previous.replacement;
  for (let i = 1; i < changes.length; ++i) {
    const change = changes[i];
    result += str.slice(previous.end, change.start);
    result += change.replacement;
    previous = change;
  }
  result += str.slice(previous.end);
  return result;
}

// src/runtime/class-collector.ts
function collectClassesFromContexts(contexts, filter) {
  const set = /* @__PURE__ */ new Set();
  for (const context of contexts) {
    if (!isObject(context) || !context.classCache) {
      continue;
    }
    for (const key of context.classCache.keys()) {
      const className = key.toString();
      if (filter(className)) {
        set.add(className);
      }
    }
  }
  return set;
}
async function collectClassesFromTailwindV4(options) {
  const set = /* @__PURE__ */ new Set();
  const v4Options = options.tailwind.v4;
  if (!v4Options) {
    return set;
  }
  const toAbsolute = (value) => {
    if (!value) {
      return void 0;
    }
    return path3.isAbsolute(value) ? value : path3.resolve(options.projectRoot, value);
  };
  const resolvedConfiguredBase = toAbsolute(v4Options.configuredBase);
  const resolvedDefaultBase = toAbsolute(v4Options.base) ?? process4.cwd();
  const resolveSources = (base) => {
    if (!v4Options.sources?.length) {
      return void 0;
    }
    return v4Options.sources.map((source) => ({
      base: source.base ?? base,
      pattern: source.pattern,
      negated: source.negated
    }));
  };
  if (v4Options.cssEntries.length > 0) {
    for (const entry of v4Options.cssEntries) {
      const filePath = path3.isAbsolute(entry) ? entry : path3.resolve(options.projectRoot, entry);
      if (!await fs3.pathExists(filePath)) {
        continue;
      }
      const css = await fs3.readFile(filePath, "utf8");
      const entryDir = path3.dirname(filePath);
      const baseForEntry = resolvedConfiguredBase ?? entryDir;
      const sources = resolveSources(baseForEntry);
      const candidates = await extractValidCandidates({
        cwd: options.projectRoot,
        base: baseForEntry,
        css,
        sources
      });
      for (const candidate of candidates) {
        if (options.filter(candidate)) {
          set.add(candidate);
        }
      }
    }
  } else {
    const baseForCss = resolvedConfiguredBase ?? resolvedDefaultBase;
    const sources = resolveSources(baseForCss);
    const candidates = await extractValidCandidates({
      cwd: options.projectRoot,
      base: baseForCss,
      css: v4Options.css,
      sources
    });
    for (const candidate of candidates) {
      if (options.filter(candidate)) {
        set.add(candidate);
      }
    }
  }
  return set;
}

// src/runtime/context-registry.ts
import { createRequire } from "module";
import fs4 from "fs-extra";
import path4 from "pathe";
var require2 = createRequire(import.meta.url);
function resolveRuntimeEntry(packageInfo, majorVersion) {
  const root = packageInfo.rootPath;
  if (majorVersion === 2) {
    const jitIndex = path4.join(root, "lib/jit/index.js");
    if (fs4.existsSync(jitIndex)) {
      return jitIndex;
    }
  } else if (majorVersion === 3) {
    const plugin = path4.join(root, "lib/plugin.js");
    const index = path4.join(root, "lib/index.js");
    if (fs4.existsSync(plugin)) {
      return plugin;
    }
    if (fs4.existsSync(index)) {
      return index;
    }
  }
  return void 0;
}
function loadRuntimeContexts(packageInfo, majorVersion, refProperty) {
  if (majorVersion === 4) {
    return [];
  }
  const entry = resolveRuntimeEntry(packageInfo, majorVersion);
  if (!entry) {
    return [];
  }
  const moduleExports = require2(entry);
  if (!moduleExports) {
    return [];
  }
  const ref = moduleExports[refProperty];
  if (!ref) {
    return [];
  }
  if (Array.isArray(ref)) {
    return ref;
  }
  if (typeof ref === "object" && Array.isArray(ref.value)) {
    return ref.value;
  }
  return [];
}

// src/runtime/process-tailwindcss.ts
import { createRequire as createRequire2 } from "module";
import path5 from "pathe";
import postcss from "postcss";
import { loadConfig } from "tailwindcss-config";
var require3 = createRequire2(import.meta.url);
async function resolveConfigPath(options) {
  if (options.config && path5.isAbsolute(options.config)) {
    return options.config;
  }
  const result = await loadConfig({ cwd: options.cwd });
  if (!result) {
    throw new Error(`Unable to locate Tailwind CSS config from ${options.cwd}`);
  }
  return result.filepath;
}
async function runTailwindBuild(options) {
  const configPath = await resolveConfigPath(options);
  const pluginName = options.postcssPlugin ?? (options.majorVersion === 4 ? "@tailwindcss/postcss" : "tailwindcss");
  if (options.majorVersion === 4) {
    return postcss([
      require3(pluginName)({
        config: configPath
      })
    ]).process("@import 'tailwindcss';", {
      from: void 0
    });
  }
  return postcss([
    require3(pluginName)({
      config: configPath
    })
  ]).process("@tailwind base;@tailwind components;@tailwind utilities;", {
    from: void 0
  });
}

// src/api/tailwindcss-patcher.ts
import process5 from "process";
import fs7 from "fs-extra";
import { getPackageInfoSync } from "local-pkg";
import path8 from "pathe";
import { coerce } from "semver";

// src/options/legacy.ts
function normalizeLegacyFeatures(patch) {
  const apply = patch?.applyPatches;
  const extend = apply?.extendLengthUnits;
  let extendOption = false;
  if (extend && typeof extend === "object") {
    extendOption = {
      ...extend,
      enabled: true
    };
  } else if (extend === true) {
    extendOption = {
      enabled: true,
      units: ["rpx"],
      overwrite: patch?.overwrite
    };
  }
  return {
    exposeContext: apply?.exportContext ?? true,
    extendLengthUnits: extendOption
  };
}
function fromLegacyOptions(options) {
  if (!options) {
    return {};
  }
  const patch = options.patch;
  const features = normalizeLegacyFeatures(patch);
  const output = patch?.output;
  const tailwindConfig = patch?.tailwindcss;
  const tailwindVersion = tailwindConfig?.version;
  const tailwindV2 = tailwindConfig?.v2;
  const tailwindV3 = tailwindConfig?.v3;
  const tailwindV4 = tailwindConfig?.v4;
  const tailwindConfigPath = tailwindV3?.config ?? tailwindV2?.config;
  const tailwindCwd = tailwindV3?.cwd ?? tailwindV2?.cwd ?? patch?.cwd;
  return {
    cwd: patch?.cwd,
    overwrite: patch?.overwrite,
    filter: patch?.filter,
    cache: typeof options.cache === "boolean" ? options.cache : options.cache ? {
      ...options.cache,
      enabled: options.cache.enabled ?? true
    } : void 0,
    output: output ? {
      file: output.filename,
      pretty: output.loose ? 2 : false,
      removeUniversalSelector: output.removeUniversalSelector
    } : void 0,
    tailwind: {
      packageName: patch?.packageName,
      version: tailwindVersion,
      resolve: patch?.resolve,
      config: tailwindConfigPath,
      cwd: tailwindCwd,
      v2: tailwindV2,
      v3: tailwindV3,
      v4: tailwindV4
    },
    features: {
      exposeContext: features.exposeContext,
      extendLengthUnits: features.extendLengthUnits
    }
  };
}
function fromUnifiedConfig(registry) {
  if (!registry) {
    return {};
  }
  const tailwind = registry.tailwind;
  const output = registry.output;
  const pretty = (() => {
    if (output?.pretty === void 0) {
      return void 0;
    }
    if (typeof output.pretty === "boolean") {
      return output.pretty ? 2 : false;
    }
    return output.pretty;
  })();
  return {
    output: output ? {
      file: output.file,
      pretty,
      removeUniversalSelector: output.stripUniversalSelector
    } : void 0,
    tailwind: tailwind ? {
      version: tailwind.version,
      packageName: tailwind.package,
      resolve: tailwind.resolve,
      config: tailwind.config,
      cwd: tailwind.cwd,
      v2: tailwind.legacy,
      v3: tailwind.classic,
      v4: tailwind.next
    } : void 0
  };
}

// src/patching/operations/export-context/index.ts
import fs5 from "fs-extra";
import path6 from "pathe";

// src/patching/operations/export-context/postcss-v2.ts
import * as t from "@babel/types";

// src/babel/index.ts
import _babelGenerate from "@babel/generator";
import _babelTraverse from "@babel/traverse";
import { parse, parseExpression } from "@babel/parser";
function _interopDefaultCompat(e) {
  return e && typeof e === "object" && "default" in e ? e.default : e;
}
var generate = _interopDefaultCompat(_babelGenerate);
var traverse = _interopDefaultCompat(_babelTraverse);

// src/patching/operations/export-context/postcss-v2.ts
var IDENTIFIER_RE = /^[A-Z_$][\w$]*$/i;
function toIdentifierName(property) {
  if (!property) {
    return "contextRef";
  }
  const sanitized = property.replace(/[^\w$]/gu, "_");
  if (/^\d/.test(sanitized)) {
    return `_${sanitized}`;
  }
  return sanitized || "contextRef";
}
function createExportsMember(property) {
  if (IDENTIFIER_RE.test(property)) {
    return t.memberExpression(t.identifier("exports"), t.identifier(property));
  }
  return t.memberExpression(t.identifier("exports"), t.stringLiteral(property), true);
}
function transformProcessTailwindFeaturesReturnContextV2(content) {
  const ast = parse(content, {
    sourceType: "unambiguous"
  });
  let hasPatched = false;
  traverse(ast, {
    FunctionDeclaration(path10) {
      const node = path10.node;
      if (node.id?.name !== "processTailwindFeatures" || node.body.body.length !== 1 || !t.isReturnStatement(node.body.body[0])) {
        return;
      }
      const returnStatement3 = node.body.body[0];
      if (!t.isFunctionExpression(returnStatement3.argument)) {
        return;
      }
      const body = returnStatement3.argument.body.body;
      const lastStatement = body[body.length - 1];
      const alreadyReturnsContext = Boolean(
        t.isReturnStatement(lastStatement) && t.isIdentifier(lastStatement.argument) && lastStatement.argument.name === "context"
      );
      hasPatched = alreadyReturnsContext;
      if (!alreadyReturnsContext) {
        body.push(t.returnStatement(t.identifier("context")));
      }
    }
  });
  return {
    code: hasPatched ? content : generate(ast).code,
    hasPatched
  };
}
function transformPostcssPluginV2(content, options) {
  const refIdentifier = t.identifier(toIdentifierName(options.refProperty));
  const exportMember = createExportsMember(options.refProperty);
  const valueMember = t.memberExpression(refIdentifier, t.identifier("value"));
  const ast = parse(content);
  let hasPatched = false;
  traverse(ast, {
    Program(path10) {
      const program = path10.node;
      const index = program.body.findIndex((statement) => {
        return t.isFunctionDeclaration(statement) && statement.id?.name === "_default";
      });
      if (index === -1) {
        return;
      }
      const previous = program.body[index - 1];
      const beforePrevious = program.body[index - 2];
      const alreadyHasVariable = Boolean(
        previous && t.isVariableDeclaration(previous) && previous.declarations.length === 1 && t.isIdentifier(previous.declarations[0].id) && previous.declarations[0].id.name === refIdentifier.name
      );
      const alreadyAssignsExports = Boolean(
        beforePrevious && t.isExpressionStatement(beforePrevious) && t.isAssignmentExpression(beforePrevious.expression) && t.isMemberExpression(beforePrevious.expression.left) && t.isIdentifier(beforePrevious.expression.right) && beforePrevious.expression.right.name === refIdentifier.name && generate(beforePrevious.expression.left).code === generate(exportMember).code
      );
      hasPatched = alreadyHasVariable && alreadyAssignsExports;
      if (!alreadyHasVariable) {
        program.body.splice(
          index,
          0,
          t.variableDeclaration("var", [
            t.variableDeclarator(
              refIdentifier,
              t.objectExpression([
                t.objectProperty(t.identifier("value"), t.arrayExpression())
              ])
            )
          ]),
          t.expressionStatement(
            t.assignmentExpression("=", exportMember, refIdentifier)
          )
        );
      }
    },
    FunctionDeclaration(path10) {
      if (hasPatched) {
        return;
      }
      const fn = path10.node;
      if (fn.id?.name !== "_default") {
        return;
      }
      if (fn.body.body.length !== 1 || !t.isReturnStatement(fn.body.body[0])) {
        return;
      }
      const returnStatement3 = fn.body.body[0];
      if (!t.isCallExpression(returnStatement3.argument) || !t.isMemberExpression(returnStatement3.argument.callee) || !t.isArrayExpression(returnStatement3.argument.callee.object)) {
        return;
      }
      const fnExpression = returnStatement3.argument.callee.object.elements[1];
      if (!fnExpression || !t.isFunctionExpression(fnExpression)) {
        return;
      }
      const block = fnExpression.body;
      const statements = block.body;
      if (t.isExpressionStatement(statements[0]) && t.isAssignmentExpression(statements[0].expression) && t.isNumericLiteral(statements[0].expression.right)) {
        hasPatched = true;
        return;
      }
      const lastStatement = statements[statements.length - 1];
      if (lastStatement && t.isExpressionStatement(lastStatement)) {
        statements[statements.length - 1] = t.expressionStatement(
          t.callExpression(
            t.memberExpression(valueMember, t.identifier("push")),
            [lastStatement.expression]
          )
        );
      }
      const index = statements.findIndex((statement) => t.isIfStatement(statement));
      if (index > -1) {
        const ifStatement = statements[index];
        if (t.isBlockStatement(ifStatement.consequent) && ifStatement.consequent.body[1] && t.isForOfStatement(ifStatement.consequent.body[1])) {
          const forOf = ifStatement.consequent.body[1];
          if (t.isBlockStatement(forOf.body) && forOf.body.body.length === 1) {
            const nestedIf = forOf.body.body[0];
            if (nestedIf && t.isIfStatement(nestedIf) && t.isBlockStatement(nestedIf.consequent) && nestedIf.consequent.body.length === 1 && t.isExpressionStatement(nestedIf.consequent.body[0])) {
              nestedIf.consequent.body[0] = t.expressionStatement(
                t.callExpression(
                  t.memberExpression(valueMember, t.identifier("push")),
                  [nestedIf.consequent.body[0].expression]
                )
              );
            }
          }
        }
      }
      statements.unshift(
        t.expressionStatement(
          t.assignmentExpression(
            "=",
            t.memberExpression(valueMember, t.identifier("length")),
            t.numericLiteral(0)
          )
        )
      );
    }
  });
  return {
    code: hasPatched ? content : generate(ast).code,
    hasPatched
  };
}

// src/patching/operations/export-context/postcss-v3.ts
import * as t2 from "@babel/types";
var IDENTIFIER_RE2 = /^[A-Z_$][\w$]*$/i;
function toIdentifierName2(property) {
  if (!property) {
    return "contextRef";
  }
  const sanitized = property.replace(/[^\w$]/gu, "_");
  if (/^\d/.test(sanitized)) {
    return `_${sanitized}`;
  }
  return sanitized || "contextRef";
}
function createModuleExportsMember(property) {
  const object = t2.memberExpression(t2.identifier("module"), t2.identifier("exports"));
  if (IDENTIFIER_RE2.test(property)) {
    return t2.memberExpression(object, t2.identifier(property));
  }
  return t2.memberExpression(object, t2.stringLiteral(property), true);
}
function transformProcessTailwindFeaturesReturnContext(content) {
  const ast = parse(content);
  let hasPatched = false;
  traverse(ast, {
    FunctionDeclaration(path10) {
      const node = path10.node;
      if (node.id?.name !== "processTailwindFeatures" || node.body.body.length !== 1) {
        return;
      }
      const [returnStatement3] = node.body.body;
      if (!t2.isReturnStatement(returnStatement3) || !t2.isFunctionExpression(returnStatement3.argument)) {
        return;
      }
      const expression = returnStatement3.argument;
      const body = expression.body.body;
      const lastStatement = body[body.length - 1];
      const alreadyReturnsContext = Boolean(
        t2.isReturnStatement(lastStatement) && t2.isIdentifier(lastStatement.argument) && lastStatement.argument.name === "context"
      );
      hasPatched = alreadyReturnsContext;
      if (!alreadyReturnsContext) {
        body.push(t2.returnStatement(t2.identifier("context")));
      }
    }
  });
  return {
    code: hasPatched ? content : generate(ast).code,
    hasPatched
  };
}
function transformPostcssPlugin(content, { refProperty }) {
  const ast = parse(content);
  const refIdentifier = t2.identifier(toIdentifierName2(refProperty));
  const moduleExportsMember = createModuleExportsMember(refProperty);
  const valueMember = t2.memberExpression(refIdentifier, t2.identifier("value"));
  let hasPatched = false;
  traverse(ast, {
    Program(path10) {
      const program = path10.node;
      const index = program.body.findIndex((statement) => {
        return t2.isExpressionStatement(statement) && t2.isAssignmentExpression(statement.expression) && t2.isMemberExpression(statement.expression.left) && t2.isFunctionExpression(statement.expression.right) && statement.expression.right.id?.name === "tailwindcss";
      });
      if (index === -1) {
        return;
      }
      const previousStatement = program.body[index - 1];
      const lastStatement = program.body[program.body.length - 1];
      const alreadyHasVariable = Boolean(
        previousStatement && t2.isVariableDeclaration(previousStatement) && previousStatement.declarations.length === 1 && t2.isIdentifier(previousStatement.declarations[0].id) && previousStatement.declarations[0].id.name === refIdentifier.name
      );
      const alreadyAssignsModuleExports = Boolean(
        t2.isExpressionStatement(lastStatement) && t2.isAssignmentExpression(lastStatement.expression) && t2.isMemberExpression(lastStatement.expression.left) && t2.isIdentifier(lastStatement.expression.right) && lastStatement.expression.right.name === refIdentifier.name && generate(lastStatement.expression.left).code === generate(moduleExportsMember).code
      );
      hasPatched = alreadyHasVariable && alreadyAssignsModuleExports;
      if (!alreadyHasVariable) {
        program.body.splice(
          index,
          0,
          t2.variableDeclaration("const", [
            t2.variableDeclarator(
              refIdentifier,
              t2.objectExpression([
                t2.objectProperty(t2.identifier("value"), t2.arrayExpression())
              ])
            )
          ])
        );
      }
      if (!alreadyAssignsModuleExports) {
        program.body.push(
          t2.expressionStatement(
            t2.assignmentExpression("=", moduleExportsMember, refIdentifier)
          )
        );
      }
    },
    FunctionExpression(path10) {
      if (hasPatched) {
        return;
      }
      const fn = path10.node;
      if (fn.id?.name !== "tailwindcss" || fn.body.body.length !== 1) {
        return;
      }
      const [returnStatement3] = fn.body.body;
      if (!returnStatement3 || !t2.isReturnStatement(returnStatement3) || !t2.isObjectExpression(returnStatement3.argument)) {
        return;
      }
      const properties = returnStatement3.argument.properties;
      if (properties.length !== 2) {
        return;
      }
      const pluginsProperty = properties.find(
        (prop) => t2.isObjectProperty(prop) && t2.isIdentifier(prop.key) && prop.key.name === "plugins"
      );
      if (!pluginsProperty || !t2.isObjectProperty(pluginsProperty) || !t2.isCallExpression(pluginsProperty.value) || !t2.isMemberExpression(pluginsProperty.value.callee) || !t2.isArrayExpression(pluginsProperty.value.callee.object)) {
        return;
      }
      const pluginsArray = pluginsProperty.value.callee.object.elements;
      const targetPlugin = pluginsArray[1];
      if (!targetPlugin || !t2.isFunctionExpression(targetPlugin)) {
        return;
      }
      const block = targetPlugin.body;
      const statements = block.body;
      const last = statements[statements.length - 1];
      if (last && t2.isExpressionStatement(last)) {
        statements[statements.length - 1] = t2.expressionStatement(
          t2.callExpression(
            t2.memberExpression(valueMember, t2.identifier("push")),
            [last.expression]
          )
        );
      }
      const index = statements.findIndex((s) => t2.isIfStatement(s));
      if (index > -1) {
        const ifStatement = statements[index];
        if (t2.isBlockStatement(ifStatement.consequent)) {
          const [, second] = ifStatement.consequent.body;
          if (second && t2.isForOfStatement(second) && t2.isBlockStatement(second.body)) {
            const bodyStatement = second.body.body[0];
            if (bodyStatement && t2.isIfStatement(bodyStatement) && t2.isBlockStatement(bodyStatement.consequent) && bodyStatement.consequent.body.length === 1 && t2.isExpressionStatement(bodyStatement.consequent.body[0])) {
              bodyStatement.consequent.body[0] = t2.expressionStatement(
                t2.callExpression(
                  t2.memberExpression(valueMember, t2.identifier("push")),
                  [bodyStatement.consequent.body[0].expression]
                )
              );
            }
          }
        }
      }
      statements.unshift(
        t2.expressionStatement(
          t2.assignmentExpression(
            "=",
            t2.memberExpression(valueMember, t2.identifier("length")),
            t2.numericLiteral(0)
          )
        )
      );
    }
  });
  return {
    code: hasPatched ? content : generate(ast).code,
    hasPatched
  };
}

// src/patching/operations/export-context/index.ts
function writeFileIfRequired(filePath, code, overwrite, successMessage) {
  if (!overwrite) {
    return;
  }
  fs5.writeFileSync(filePath, code, {
    encoding: "utf8"
  });
  logger_default.success(successMessage);
}
function applyExposeContextPatch(params) {
  const { rootDir, refProperty, overwrite, majorVersion } = params;
  const result = {
    applied: false,
    files: {}
  };
  if (majorVersion === 3) {
    const processFileRelative = "lib/processTailwindFeatures.js";
    const processFilePath = path6.resolve(rootDir, processFileRelative);
    if (fs5.existsSync(processFilePath)) {
      const content = fs5.readFileSync(processFilePath, "utf8");
      const { code, hasPatched } = transformProcessTailwindFeaturesReturnContext(content);
      result.files[processFileRelative] = code;
      if (!hasPatched) {
        writeFileIfRequired(
          processFilePath,
          code,
          overwrite,
          "Patched Tailwind CSS processTailwindFeatures to expose runtime context."
        );
        result.applied = true;
      }
    }
    const pluginCandidates = ["lib/plugin.js", "lib/index.js"];
    const pluginRelative = pluginCandidates.find((candidate) => fs5.existsSync(path6.resolve(rootDir, candidate)));
    if (pluginRelative) {
      const pluginPath = path6.resolve(rootDir, pluginRelative);
      const content = fs5.readFileSync(pluginPath, "utf8");
      const { code, hasPatched } = transformPostcssPlugin(content, { refProperty });
      result.files[pluginRelative] = code;
      if (!hasPatched) {
        writeFileIfRequired(
          pluginPath,
          code,
          overwrite,
          "Patched Tailwind CSS plugin entry to collect runtime contexts."
        );
        result.applied = true;
      }
    }
  } else if (majorVersion === 2) {
    const processFileRelative = "lib/jit/processTailwindFeatures.js";
    const processFilePath = path6.resolve(rootDir, processFileRelative);
    if (fs5.existsSync(processFilePath)) {
      const content = fs5.readFileSync(processFilePath, "utf8");
      const { code, hasPatched } = transformProcessTailwindFeaturesReturnContextV2(content);
      result.files[processFileRelative] = code;
      if (!hasPatched) {
        writeFileIfRequired(
          processFilePath,
          code,
          overwrite,
          "Patched Tailwind CSS JIT processTailwindFeatures to expose runtime context."
        );
        result.applied = true;
      }
    }
    const pluginRelative = "lib/jit/index.js";
    const pluginPath = path6.resolve(rootDir, pluginRelative);
    if (fs5.existsSync(pluginPath)) {
      const content = fs5.readFileSync(pluginPath, "utf8");
      const { code, hasPatched } = transformPostcssPluginV2(content, { refProperty });
      result.files[pluginRelative] = code;
      if (!hasPatched) {
        writeFileIfRequired(
          pluginPath,
          code,
          overwrite,
          "Patched Tailwind CSS JIT entry to collect runtime contexts."
        );
        result.applied = true;
      }
    }
  }
  return result;
}

// src/patching/operations/extend-length-units.ts
import * as t3 from "@babel/types";
import fs6 from "fs-extra";
import path7 from "pathe";
function updateLengthUnitsArray(content, options) {
  const { variableName = "lengthUnits", units } = options;
  const ast = parse(content);
  let arrayRef;
  let changed = false;
  traverse(ast, {
    Identifier(path10) {
      if (path10.node.name === variableName && t3.isVariableDeclarator(path10.parent) && t3.isArrayExpression(path10.parent.init)) {
        arrayRef = path10.parent.init;
        const existing = new Set(
          path10.parent.init.elements.map((element) => t3.isStringLiteral(element) ? element.value : void 0).filter(Boolean)
        );
        for (const unit of units) {
          if (!existing.has(unit)) {
            path10.parent.init.elements = path10.parent.init.elements.map((element) => {
              if (t3.isStringLiteral(element)) {
                return t3.stringLiteral(element.value);
              }
              return element;
            });
            path10.parent.init.elements.push(t3.stringLiteral(unit));
            changed = true;
          }
        }
      }
    }
  });
  return {
    arrayRef,
    changed
  };
}
function applyExtendLengthUnitsPatchV3(rootDir, options) {
  if (!options.enabled) {
    return { changed: false, code: void 0 };
  }
  const opts = {
    ...options,
    lengthUnitsFilePath: options.lengthUnitsFilePath ?? "lib/util/dataTypes.js",
    variableName: options.variableName ?? "lengthUnits"
  };
  const dataTypesFilePath = path7.resolve(rootDir, opts.lengthUnitsFilePath);
  const exists = fs6.existsSync(dataTypesFilePath);
  if (!exists) {
    return { changed: false, code: void 0 };
  }
  const content = fs6.readFileSync(dataTypesFilePath, "utf8");
  const { arrayRef, changed } = updateLengthUnitsArray(content, opts);
  if (!arrayRef || !changed) {
    return { changed: false, code: void 0 };
  }
  const { code } = generate(arrayRef, {
    jsescOption: { quotes: "single" }
  });
  if (arrayRef.start != null && arrayRef.end != null) {
    const nextCode = `${content.slice(0, arrayRef.start)}${code}${content.slice(arrayRef.end)}`;
    if (opts.overwrite) {
      const target = opts.destPath ? path7.resolve(opts.destPath) : dataTypesFilePath;
      fs6.writeFileSync(target, nextCode, "utf8");
      logger_default.success("Patched Tailwind CSS length unit list (v3).");
    }
    return {
      changed: true,
      code: nextCode
    };
  }
  return {
    changed: false,
    code: void 0
  };
}
function applyExtendLengthUnitsPatchV4(rootDir, options) {
  if (!options.enabled) {
    return { files: [], changed: false };
  }
  const opts = { ...options };
  const distDir = path7.resolve(rootDir, "dist");
  if (!fs6.existsSync(distDir)) {
    return { files: [], changed: false };
  }
  const entries = fs6.readdirSync(distDir);
  const chunkNames = entries.filter((entry) => entry.endsWith(".js") || entry.endsWith(".mjs"));
  const pattern = /\[\s*["']cm["'],\s*["']mm["'],[\w,"']+\]/;
  const candidates = chunkNames.map((chunkName) => {
    const file = path7.join(distDir, chunkName);
    const code = fs6.readFileSync(file, "utf8");
    const match = pattern.exec(code);
    if (!match) {
      return null;
    }
    return {
      file,
      code,
      match,
      hasPatched: false
    };
  }).filter((candidate) => candidate !== null);
  for (const item of candidates) {
    const { code, file, match } = item;
    const ast = parse(match[0], { sourceType: "unambiguous" });
    traverse(ast, {
      ArrayExpression(path10) {
        for (const unit of opts.units) {
          if (path10.node.elements.some((element) => t3.isStringLiteral(element) && element.value === unit)) {
            item.hasPatched = true;
            return;
          }
          path10.node.elements.push(t3.stringLiteral(unit));
        }
      }
    });
    if (item.hasPatched) {
      continue;
    }
    const { code: replacement } = generate(ast, { minified: true });
    const start = match.index ?? 0;
    const end = start + match[0].length;
    item.code = spliceChangesIntoString(code, [
      {
        start,
        end,
        replacement: replacement.endsWith(";") ? replacement.slice(0, -1) : replacement
      }
    ]);
    if (opts.overwrite) {
      fs6.writeFileSync(file, item.code, "utf8");
    }
  }
  if (candidates.some((file) => !file.hasPatched)) {
    logger_default.success("Patched Tailwind CSS length unit list (v4).");
  }
  return {
    changed: candidates.some((file) => !file.hasPatched),
    files: candidates
  };
}

// src/patching/patch-runner.ts
function applyTailwindPatches(context) {
  const { packageInfo, options, majorVersion } = context;
  const results = {};
  if (options.features.exposeContext.enabled && (majorVersion === 2 || majorVersion === 3)) {
    results.exposeContext = applyExposeContextPatch({
      rootDir: packageInfo.rootPath,
      refProperty: options.features.exposeContext.refProperty,
      overwrite: options.overwrite,
      majorVersion
    });
  }
  if (options.features.extendLengthUnits?.enabled) {
    if (majorVersion === 3) {
      results.extendLengthUnits = applyExtendLengthUnitsPatchV3(
        packageInfo.rootPath,
        options.features.extendLengthUnits
      );
    } else if (majorVersion === 4) {
      results.extendLengthUnits = applyExtendLengthUnitsPatchV4(
        packageInfo.rootPath,
        options.features.extendLengthUnits
      );
    }
  }
  return results;
}

// src/api/tailwindcss-patcher.ts
function resolveMajorVersion(version, hint) {
  if (hint && [2, 3, 4].includes(hint)) {
    return hint;
  }
  if (version) {
    const coerced = coerce(version);
    if (coerced) {
      const major = coerced.major;
      if (major === 2 || major === 3 || major === 4) {
        return major;
      }
      if (major >= 4) {
        return 4;
      }
    }
  }
  return 3;
}
function resolveTailwindExecutionOptions(normalized, majorVersion) {
  const base = normalized.tailwind;
  if (majorVersion === 2 && base.v2) {
    return {
      cwd: base.v2.cwd ?? base.cwd ?? normalized.projectRoot,
      config: base.v2.config ?? base.config,
      postcssPlugin: base.v2.postcssPlugin ?? base.postcssPlugin
    };
  }
  if (majorVersion === 3 && base.v3) {
    return {
      cwd: base.v3.cwd ?? base.cwd ?? normalized.projectRoot,
      config: base.v3.config ?? base.config,
      postcssPlugin: base.v3.postcssPlugin ?? base.postcssPlugin
    };
  }
  return {
    cwd: base.cwd ?? normalized.projectRoot,
    config: base.config,
    postcssPlugin: base.postcssPlugin
  };
}
var TailwindcssPatcher = class {
  options;
  packageInfo;
  majorVersion;
  cacheStore;
  constructor(options = {}) {
    const resolvedOptions = options && typeof options === "object" && "patch" in options ? fromLegacyOptions(options) : options;
    this.options = normalizeOptions(resolvedOptions);
    const packageInfo = getPackageInfoSync(
      this.options.tailwind.packageName,
      this.options.tailwind.resolve
    );
    if (!packageInfo) {
      throw new Error(`Unable to locate Tailwind CSS package "${this.options.tailwind.packageName}".`);
    }
    this.packageInfo = packageInfo;
    this.majorVersion = resolveMajorVersion(
      this.packageInfo.version,
      this.options.tailwind.versionHint
    );
    this.cacheStore = new CacheStore(this.options.cache);
  }
  async patch() {
    return applyTailwindPatches({
      packageInfo: this.packageInfo,
      options: this.options,
      majorVersion: this.majorVersion
    });
  }
  getContexts() {
    return loadRuntimeContexts(
      this.packageInfo,
      this.majorVersion,
      this.options.features.exposeContext.refProperty
    );
  }
  async runTailwindBuildIfNeeded() {
    if (this.majorVersion === 2 || this.majorVersion === 3) {
      const executionOptions = resolveTailwindExecutionOptions(this.options, this.majorVersion);
      await runTailwindBuild({
        cwd: executionOptions.cwd,
        config: executionOptions.config,
        majorVersion: this.majorVersion,
        postcssPlugin: executionOptions.postcssPlugin
      });
    }
  }
  async collectClassSet() {
    if (this.majorVersion === 4) {
      return collectClassesFromTailwindV4(this.options);
    }
    const contexts = this.getContexts();
    return collectClassesFromContexts(contexts, this.options.filter);
  }
  async mergeWithCache(set) {
    if (!this.options.cache.enabled) {
      return set;
    }
    const existing = await this.cacheStore.read();
    if (this.options.cache.strategy === "merge") {
      for (const value of existing) {
        set.add(value);
      }
      await this.cacheStore.write(set);
    } else {
      if (set.size > 0) {
        await this.cacheStore.write(set);
      } else {
        return existing;
      }
    }
    return set;
  }
  mergeWithCacheSync(set) {
    if (!this.options.cache.enabled) {
      return set;
    }
    const existing = this.cacheStore.readSync();
    if (this.options.cache.strategy === "merge") {
      for (const value of existing) {
        set.add(value);
      }
      this.cacheStore.writeSync(set);
    } else {
      if (set.size > 0) {
        this.cacheStore.writeSync(set);
      } else {
        return existing;
      }
    }
    return set;
  }
  async getClassSet() {
    await this.runTailwindBuildIfNeeded();
    const set = await this.collectClassSet();
    return this.mergeWithCache(set);
  }
  getClassSetSync() {
    if (this.majorVersion === 4) {
      throw new Error("getClassSetSync is not supported for Tailwind CSS v4 projects. Use getClassSet instead.");
    }
    const contexts = this.getContexts();
    const set = collectClassesFromContexts(contexts, this.options.filter);
    const merged = this.mergeWithCacheSync(set);
    if (contexts.length === 0 && merged.size === 0) {
      return void 0;
    }
    return merged;
  }
  async extract(options) {
    const shouldWrite = options?.write ?? this.options.output.enabled;
    const classSet = await this.getClassSet();
    const classList = Array.from(classSet);
    const result = {
      classList,
      classSet
    };
    if (!shouldWrite || !this.options.output.file) {
      return result;
    }
    const target = path8.resolve(this.options.output.file);
    await fs7.ensureDir(path8.dirname(target));
    if (this.options.output.format === "json") {
      const spaces = typeof this.options.output.pretty === "number" ? this.options.output.pretty : void 0;
      await fs7.writeJSON(target, classList, { spaces });
    } else {
      await fs7.writeFile(target, `${classList.join("\n")}
`, "utf8");
    }
    logger_default.success(`Tailwind CSS class list saved to ${target.replace(process5.cwd(), ".")}`);
    return {
      ...result,
      filename: target
    };
  }
  // Backwards compatibility helper used by tests and API consumers.
  extractValidCandidates = extractValidCandidates;
  async collectContentTokens(options) {
    return extractProjectCandidatesWithPositions({
      cwd: options?.cwd ?? this.options.projectRoot,
      sources: options?.sources ?? this.options.tailwind.v4?.sources ?? []
    });
  }
  async collectContentTokensByFile(options) {
    const report = await this.collectContentTokens({
      cwd: options?.cwd,
      sources: options?.sources
    });
    return groupTokensByFile(report, {
      key: options?.key,
      stripAbsolutePaths: options?.stripAbsolutePaths
    });
  }
};

// src/cli/commands.ts
import process6 from "process";
import { CONFIG_NAME, getConfig, initConfig } from "@tailwindcss-mangle/config";

// ../../node_modules/.pnpm/defu@6.1.4/node_modules/defu/dist/defu.mjs
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject(value) && isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
var defu = createDefu();
var defuFn = createDefu((object, key, currentValue) => {
  if (object[key] !== void 0 && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});
var defuArrayFn = createDefu((object, key, currentValue) => {
  if (Array.isArray(object[key]) && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});

// ../shared/src/utils.ts
var defuOverrideArray = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = value;
    return true;
  }
});
var preserveClassNames = [
  // https://tailwindcss.com/docs/transition-timing-function start
  // https://github.com/sonofmagic/tailwindcss-mangle/issues/21
  "ease-out",
  "ease-linear",
  "ease-in",
  "ease-in-out"
  // https://tailwindcss.com/docs/transition-timing-function end
];
var preserveClassNamesMap = preserveClassNames.reduce((acc, cur) => {
  acc[cur] = true;
  return acc;
}, {});
var acceptChars = [..."abcdefghijklmnopqrstuvwxyz"];

// src/cli/commands.ts
import cac from "cac";
import fs8 from "fs-extra";
import path9 from "pathe";
var tailwindcssPatchCommands = ["install", "extract", "tokens", "init"];
var TOKEN_FORMATS = ["json", "lines", "grouped-json"];
var DEFAULT_TOKEN_REPORT = ".tw-patch/tw-token-report.json";
function formatTokenLine(entry) {
  return `${entry.relativeFile}:${entry.line}:${entry.column} ${entry.rawCandidate} (${entry.start}-${entry.end})`;
}
function formatGroupedPreview(map, limit = 3) {
  const files = Object.keys(map);
  if (!files.length) {
    return { preview: "", moreFiles: 0 };
  }
  const lines = files.slice(0, limit).map((file) => {
    const tokens = map[file];
    const sample = tokens.slice(0, 3).map((token) => token.rawCandidate).join(", ");
    const suffix = tokens.length > 3 ? ", \u2026" : "";
    return `${file}: ${tokens.length} tokens (${sample}${suffix})`;
  });
  return {
    preview: lines.join("\n"),
    moreFiles: Math.max(0, files.length - limit)
  };
}
function resolveCwd(rawCwd) {
  if (!rawCwd) {
    return process6.cwd();
  }
  return path9.resolve(rawCwd);
}
function createDefaultRunner(factory) {
  let promise;
  return () => {
    if (!promise) {
      promise = factory();
    }
    return promise;
  };
}
async function loadPatchOptionsForCwd(cwd, overrides) {
  const { config } = await getConfig(cwd);
  const legacyConfig = config;
  const base = config?.registry ? fromUnifiedConfig(config.registry) : legacyConfig?.patch ? fromLegacyOptions({ patch: legacyConfig.patch }) : {};
  const merged = defu(overrides ?? {}, base);
  return merged;
}
function createCommandContext(cli, command, commandName, args, cwd) {
  let cachedOptions;
  let cachedPatcher;
  let cachedConfig;
  const loadPatchOptionsForContext = (overrides) => {
    if (overrides) {
      return loadPatchOptionsForCwd(cwd, overrides);
    }
    if (!cachedOptions) {
      cachedOptions = loadPatchOptionsForCwd(cwd);
    }
    return cachedOptions;
  };
  const createPatcherForContext = async (overrides) => {
    if (overrides) {
      const patchOptions = await loadPatchOptionsForCwd(cwd, overrides);
      return new TailwindcssPatcher(patchOptions);
    }
    if (!cachedPatcher) {
      cachedPatcher = loadPatchOptionsForContext().then((options) => new TailwindcssPatcher(options));
    }
    return cachedPatcher;
  };
  return {
    cli,
    command,
    commandName,
    args,
    cwd,
    logger: logger_default,
    loadConfig: () => {
      if (!cachedConfig) {
        cachedConfig = getConfig(cwd);
      }
      return cachedConfig;
    },
    loadPatchOptions: loadPatchOptionsForContext,
    createPatcher: createPatcherForContext
  };
}
function createCwdOptionDefinition(description = "Working directory") {
  return {
    flags: "--cwd <dir>",
    description,
    config: { default: process6.cwd() }
  };
}
function buildDefaultCommandDefinitions() {
  return {
    install: {
      description: "Apply Tailwind CSS runtime patches",
      optionDefs: [createCwdOptionDefinition()]
    },
    extract: {
      description: "Collect generated class names into a cache file",
      optionDefs: [
        createCwdOptionDefinition(),
        { flags: "--output <file>", description: "Override output file path" },
        { flags: "--format <format>", description: "Output format (json|lines)" },
        { flags: "--css <file>", description: "Tailwind CSS entry CSS when using v4" },
        { flags: "--no-write", description: "Skip writing to disk" }
      ]
    },
    tokens: {
      description: "Extract Tailwind tokens with file/position metadata",
      optionDefs: [
        createCwdOptionDefinition(),
        { flags: "--output <file>", description: "Override output file path", config: { default: DEFAULT_TOKEN_REPORT } },
        {
          flags: "--format <format>",
          description: "Output format (json|lines|grouped-json)",
          config: { default: "json" }
        },
        {
          flags: "--group-key <key>",
          description: "Grouping key for grouped-json output (relative|absolute)",
          config: { default: "relative" }
        },
        { flags: "--no-write", description: "Skip writing to disk" }
      ]
    },
    init: {
      description: "Generate a tailwindcss-patch config file",
      optionDefs: [createCwdOptionDefinition()]
    }
  };
}
function addPrefixIfMissing(value, prefix) {
  if (!prefix || value.startsWith(prefix)) {
    return value;
  }
  return `${prefix}${value}`;
}
function resolveCommandNames(command, mountOptions, prefix) {
  const override = mountOptions.commandOptions?.[command];
  const baseName = override?.name ?? command;
  const name = addPrefixIfMissing(baseName, prefix);
  const aliases = (override?.aliases ?? []).map((alias) => addPrefixIfMissing(alias, prefix));
  return { name, aliases };
}
function resolveOptionDefinitions(defaults, override) {
  if (!override) {
    return defaults;
  }
  const appendDefaults = override.appendDefaultOptions ?? true;
  const customDefs = override.optionDefs ?? [];
  if (!appendDefaults) {
    return customDefs;
  }
  if (customDefs.length === 0) {
    return defaults;
  }
  return [...defaults, ...customDefs];
}
function applyCommandOptions(command, optionDefs) {
  for (const option of optionDefs) {
    command.option(option.flags, option.description ?? "", option.config);
  }
}
function runWithCommandHandler(cli, command, commandName, args, handler, defaultHandler) {
  const cwd = resolveCwd(args.cwd);
  const context = createCommandContext(cli, command, commandName, args, cwd);
  const runDefault = createDefaultRunner(() => defaultHandler(context));
  if (!handler) {
    return runDefault();
  }
  return handler(context, runDefault);
}
function resolveCommandMetadata(command, mountOptions, prefix, defaults) {
  const names = resolveCommandNames(command, mountOptions, prefix);
  const definition = defaults[command];
  const override = mountOptions.commandOptions?.[command];
  const description = override?.description ?? definition.description;
  const optionDefs = resolveOptionDefinitions(definition.optionDefs, override);
  return { ...names, description, optionDefs };
}
async function installCommandDefaultHandler(ctx) {
  const patcher = await ctx.createPatcher();
  await patcher.patch();
  logger_default.success("Tailwind CSS runtime patched successfully.");
}
async function extractCommandDefaultHandler(ctx) {
  const { args } = ctx;
  const overrides = {};
  let hasOverrides = false;
  if (args.output || args.format) {
    overrides.output = {
      file: args.output,
      format: args.format
    };
    hasOverrides = true;
  }
  if (args.css) {
    overrides.tailwind = {
      v4: {
        cssEntries: [args.css]
      }
    };
    hasOverrides = true;
  }
  const patcher = await ctx.createPatcher(hasOverrides ? overrides : void 0);
  const result = await patcher.extract({ write: args.write });
  if (result.filename) {
    logger_default.success(`Collected ${result.classList.length} classes \u2192 ${result.filename}`);
  } else {
    logger_default.success(`Collected ${result.classList.length} classes.`);
  }
  return result;
}
async function tokensCommandDefaultHandler(ctx) {
  const { args } = ctx;
  const patcher = await ctx.createPatcher();
  const report = await patcher.collectContentTokens();
  const shouldWrite = args.write ?? true;
  let format = args.format ?? "json";
  if (!TOKEN_FORMATS.includes(format)) {
    format = "json";
  }
  const targetFile = args.output ?? DEFAULT_TOKEN_REPORT;
  const groupKey = args.groupKey === "absolute" ? "absolute" : "relative";
  const buildGrouped = () => groupTokensByFile(report, {
    key: groupKey,
    stripAbsolutePaths: groupKey !== "absolute"
  });
  const grouped = format === "grouped-json" ? buildGrouped() : null;
  const resolveGrouped = () => grouped ?? buildGrouped();
  if (shouldWrite) {
    const target = path9.resolve(targetFile);
    await fs8.ensureDir(path9.dirname(target));
    if (format === "json") {
      await fs8.writeJSON(target, report, { spaces: 2 });
    } else if (format === "grouped-json") {
      await fs8.writeJSON(target, resolveGrouped(), { spaces: 2 });
    } else {
      const lines = report.entries.map(formatTokenLine);
      await fs8.writeFile(target, `${lines.join("\n")}
`, "utf8");
    }
    logger_default.success(`Collected ${report.entries.length} tokens (${format}) \u2192 ${target.replace(process6.cwd(), ".")}`);
  } else {
    logger_default.success(`Collected ${report.entries.length} tokens from ${report.filesScanned} files.`);
    if (format === "lines") {
      const preview = report.entries.slice(0, 5).map(formatTokenLine).join("\n");
      if (preview) {
        logger_default.log("");
        logger_default.info(preview);
        if (report.entries.length > 5) {
          logger_default.info(`\u2026and ${report.entries.length - 5} more.`);
        }
      }
    } else if (format === "grouped-json") {
      const map = resolveGrouped();
      const { preview, moreFiles } = formatGroupedPreview(map);
      if (preview) {
        logger_default.log("");
        logger_default.info(preview);
        if (moreFiles > 0) {
          logger_default.info(`\u2026and ${moreFiles} more files.`);
        }
      }
    } else {
      const previewEntries = report.entries.slice(0, 3);
      if (previewEntries.length) {
        logger_default.log("");
        logger_default.info(JSON.stringify(previewEntries, null, 2));
      }
    }
  }
  if (report.skippedFiles.length) {
    logger_default.warn("Skipped files:");
    for (const skipped of report.skippedFiles) {
      logger_default.warn(`  \u2022 ${skipped.file} (${skipped.reason})`);
    }
  }
  return report;
}
async function initCommandDefaultHandler(ctx) {
  await initConfig(ctx.cwd);
  logger_default.success(`\u2728 ${CONFIG_NAME}.config.ts initialized!`);
}
function mountTailwindcssPatchCommands(cli, options = {}) {
  const prefix = options.commandPrefix ?? "";
  const selectedCommands = options.commands ?? tailwindcssPatchCommands;
  const defaultDefinitions = buildDefaultCommandDefinitions();
  const registrars = {
    install: () => {
      const metadata = resolveCommandMetadata("install", options, prefix, defaultDefinitions);
      const command = cli.command(metadata.name, metadata.description);
      applyCommandOptions(command, metadata.optionDefs);
      command.action(async (args) => {
        return runWithCommandHandler(
          cli,
          command,
          "install",
          args,
          options.commandHandlers?.install,
          installCommandDefaultHandler
        );
      });
      metadata.aliases.forEach((alias) => command.alias(alias));
    },
    extract: () => {
      const metadata = resolveCommandMetadata("extract", options, prefix, defaultDefinitions);
      const command = cli.command(metadata.name, metadata.description);
      applyCommandOptions(command, metadata.optionDefs);
      command.action(async (args) => {
        return runWithCommandHandler(
          cli,
          command,
          "extract",
          args,
          options.commandHandlers?.extract,
          extractCommandDefaultHandler
        );
      });
      metadata.aliases.forEach((alias) => command.alias(alias));
    },
    tokens: () => {
      const metadata = resolveCommandMetadata("tokens", options, prefix, defaultDefinitions);
      const command = cli.command(metadata.name, metadata.description);
      applyCommandOptions(command, metadata.optionDefs);
      command.action(async (args) => {
        return runWithCommandHandler(
          cli,
          command,
          "tokens",
          args,
          options.commandHandlers?.tokens,
          tokensCommandDefaultHandler
        );
      });
      metadata.aliases.forEach((alias) => command.alias(alias));
    },
    init: () => {
      const metadata = resolveCommandMetadata("init", options, prefix, defaultDefinitions);
      const command = cli.command(metadata.name, metadata.description);
      applyCommandOptions(command, metadata.optionDefs);
      command.action(async (args) => {
        return runWithCommandHandler(
          cli,
          command,
          "init",
          args,
          options.commandHandlers?.init,
          initCommandDefaultHandler
        );
      });
      metadata.aliases.forEach((alias) => command.alias(alias));
    }
  };
  for (const name of selectedCommands) {
    const register = registrars[name];
    if (register) {
      register();
    }
  }
  return cli;
}
function createTailwindcssPatchCli(options = {}) {
  const cli = cac(options.name ?? "tw-patch");
  mountTailwindcssPatchCommands(cli, options.mountOptions);
  return cli;
}

export {
  logger_default,
  CacheStore,
  extractRawCandidatesWithPositions,
  extractRawCandidates,
  extractValidCandidates,
  extractProjectCandidatesWithPositions,
  groupTokensByFile,
  normalizeOptions,
  collectClassesFromContexts,
  collectClassesFromTailwindV4,
  loadRuntimeContexts,
  runTailwindBuild,
  TailwindcssPatcher,
  tailwindcssPatchCommands,
  mountTailwindcssPatchCommands,
  createTailwindcssPatchCli
};
