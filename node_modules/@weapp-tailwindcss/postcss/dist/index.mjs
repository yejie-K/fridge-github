import "./chunk-WAXGOBY2.mjs";

// src/handler.ts
import { defuOverrideArray as defuOverrideArray3 } from "@weapp-tailwindcss/shared";
import postcss from "postcss";

// src/defaults.ts
function getDefaultOptions(options) {
  return {
    // 参考：https://github.com/postcss/postcss-calc
    cssPresetEnv: {
      features: {
        "cascade-layers": true,
        "is-pseudo-class": {
          specificityMatchingName: "weapp-tw-ig"
        },
        "oklab-function": true,
        "color-mix": true,
        "color-functional-notation": options?.cssPresetEnv?.features?.["color-functional-notation"] ?? { preserve: false },
        // 在 calc 下，这个需要开启
        "custom-properties": options?.cssPresetEnv?.features?.["custom-properties"] ?? options?.cssCalc ? { preserve: true } : false
      },
      autoprefixer: {
        add: false
      }
    },
    // 支付宝小程序不支持，所以默认关闭
    cssRemoveProperty: true,
    // cssRemoveAtSupports: true,
    // cssRemoveAtMedia: true,
    cssSelectorReplacement: {
      root: "page",
      universal: ["view", "text"]
    }
  };
}

// src/pipeline.ts
import postcssPresetEnv from "postcss-preset-env";

// src/plugins/colorFunctionalFallback.ts
import valueParser from "postcss-value-parser";
var RGB_FUNCTION_NAME = "rgb";
var isSlashDiv = (node) => node.type === "div" && node.value === "/";
function trimNodes(nodes2) {
  let start = 0;
  let end = nodes2.length;
  while (start < end && nodes2[start]?.type === "space") {
    start += 1;
  }
  while (end > start && nodes2[end - 1]?.type === "space") {
    end -= 1;
  }
  return nodes2.slice(start, end);
}
function splitColorComponents(nodes2) {
  const parts = [];
  let current = [];
  nodes2.forEach((node) => {
    if (node.type === "div" && node.value === ",") {
      if (current.length) {
        parts.push(current);
        current = [];
      }
      return;
    }
    if (node.type === "space") {
      if (current.length) {
        parts.push(current);
        current = [];
      }
      return;
    }
    current.push(node);
  });
  if (current.length) {
    parts.push(current);
  }
  return parts;
}
var buildFunctionNodes = (content) => valueParser(content).nodes;
function convertRgbFunction(fnNode) {
  const slashIndex = fnNode.nodes.findIndex(isSlashDiv);
  if (slashIndex === -1) {
    return false;
  }
  const colorNodes = trimNodes(fnNode.nodes.slice(0, slashIndex));
  const alphaNodes = trimNodes(fnNode.nodes.slice(slashIndex + 1));
  if (!colorNodes.length || !alphaNodes.length) {
    return false;
  }
  const colorParts = splitColorComponents(colorNodes);
  if (colorParts.length !== 3) {
    return false;
  }
  const normalizedColors = colorParts.map((part) => valueParser.stringify(part).trim()).filter(Boolean);
  if (normalizedColors.length !== 3) {
    return false;
  }
  const alphaText = valueParser.stringify(alphaNodes).trim();
  if (!alphaText) {
    return false;
  }
  fnNode.value = "rgba";
  const nextValue = `${normalizedColors.join(", ")}, ${alphaText}`;
  fnNode.nodes = buildFunctionNodes(nextValue);
  return true;
}
function transformDeclaration(decl) {
  if (!decl.value || !decl.value.toLowerCase().includes(RGB_FUNCTION_NAME)) {
    return;
  }
  const parsed = valueParser(decl.value);
  let mutated = false;
  parsed.walk((node) => {
    if (node.type !== "function") {
      return;
    }
    if (node.value.toLowerCase() !== RGB_FUNCTION_NAME) {
      return;
    }
    if (convertRgbFunction(node)) {
      mutated = true;
    }
  });
  if (mutated) {
    decl.value = parsed.toString();
  }
}
function createColorFunctionalFallback() {
  return {
    postcssPlugin: "weapp-tailwindcss-color-functional-fallback",
    Declaration: transformDeclaration
  };
}
createColorFunctionalFallback.postcss = true;

// src/plugins/ctx.ts
function createContext() {
  const variablesScopeWeakMap = /* @__PURE__ */ new WeakMap();
  function isVariablesScope(rule) {
    return variablesScopeWeakMap.get(rule) === true;
  }
  function markVariablesScope(rule) {
    variablesScopeWeakMap.set(rule, true);
  }
  return {
    variablesScopeWeakMap,
    isVariablesScope,
    markVariablesScope
  };
}

// src/plugins/getCalcPlugin.ts
import postcssCalc from "@weapp-tailwindcss/postcss-calc";

// ../../node_modules/.pnpm/es-toolkit@1.42.0/node_modules/es-toolkit/dist/object/omit.mjs
function omit(obj, keys) {
  const result = { ...obj };
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    delete result[key];
  }
  return result;
}

// src/plugins/getCalcPlugin.ts
function getCalcPlugin(options) {
  if (!options.cssCalc) {
    return null;
  }
  const calcOptions = Array.isArray(options.cssCalc) ? {} : typeof options.cssCalc === "object" ? omit(options.cssCalc, ["includeCustomProperties"]) : {};
  return postcssCalc(calcOptions);
}

// src/plugins/getCustomPropertyCleaner.ts
import { regExpTest } from "@weapp-tailwindcss/shared";
import valueParser2 from "postcss-value-parser";
function getCustomPropertyCleaner(options) {
  const includeCustomProperties = Array.isArray(options.cssCalc) ? options.cssCalc : typeof options.cssCalc === "object" ? options.cssCalc.includeCustomProperties : [];
  const shouldMatchCustomProperties = Array.isArray(includeCustomProperties) && includeCustomProperties.length > 0;
  if (!shouldMatchCustomProperties) {
    return null;
  }
  return {
    postcssPlugin: "postcss-remove-include-custom-properties",
    OnceExit(root) {
      root.walkDecls((decl) => {
        const prevNode = decl.prev();
        if (!prevNode || prevNode.type !== "decl" || prevNode.prop !== decl.prop) {
          return;
        }
        if (prevNode.value === decl.value) {
          decl.remove();
          return;
        }
        if (!shouldMatchCustomProperties || !/--/.test(decl.value)) {
          return;
        }
        const parsed = valueParser2(decl.value);
        let containsIncludedCustomProperty = false;
        parsed.walk((node) => {
          if (node.type !== "function" || node.value !== "var" || containsIncludedCustomProperty) {
            return;
          }
          const match = node.nodes.find((x) => {
            return x.type === "word" && regExpTest(includeCustomProperties, x.value);
          });
          if (match) {
            containsIncludedCustomProperty = true;
          }
        });
        if (containsIncludedCustomProperty) {
          decl.remove();
        }
      });
    }
  };
}

// src/plugins/getPxTransformPlugin.ts
import { defuOverrideArray } from "@weapp-tailwindcss/shared";
import postcssPxtransform from "postcss-pxtransform";
var defaultPxTransformOptions = {
  platform: "weapp",
  unitPrecision: 5,
  propList: ["*"],
  selectorBlackList: [],
  replace: true,
  mediaQuery: false,
  minPixelValue: 0,
  designWidth: 750,
  deviceRatio: {
    375: 2,
    640: 2.34 / 2,
    750: 1,
    828: 1.81 / 2
  }
};
function getPxTransformPlugin(options) {
  if (!options.px2rpx) {
    return null;
  }
  const userOptions = typeof options.px2rpx === "object" ? options.px2rpx : {};
  return postcssPxtransform(
    defuOverrideArray(
      userOptions,
      defaultPxTransformOptions
    )
  );
}

// src/plugins/getRemTransformPlugin.ts
import { defuOverrideArray as defuOverrideArray2 } from "@weapp-tailwindcss/shared";
import postcssRem2rpx from "postcss-rem-to-responsive-pixel";
var defaultRemOptions = {
  rootValue: 32,
  propList: ["*"],
  transformUnit: "rpx"
};
var defaultStage = {
  processorStage: "OnceExit"
};
function getRemTransformPlugin(options) {
  if (!options.rem2rpx) {
    return null;
  }
  const userOptions = typeof options.rem2rpx === "object" ? options.rem2rpx : defaultRemOptions;
  const merged = defuOverrideArray2(
    userOptions,
    defaultStage
  );
  return postcssRem2rpx(merged);
}

// src/plugins/post.ts
import { defu } from "@weapp-tailwindcss/shared";

// src/compat/tailwindcss-v4.ts
import { Declaration } from "postcss";

// src/cssVarsV4.ts
function property(ident, initialValue, _syntax) {
  return {
    prop: ident,
    value: initialValue || ""
  };
}
var nullShadow = "0 0 #0000";
var nodes = [
  // 参考：https://github.com/tailwindlabs/tailwindcss/blob/main/packages/tailwindcss/src/utilities.ts#L1137
  property("--tw-border-spacing-x", "0", "<length>"),
  property("--tw-border-spacing-y", "0", "<length>"),
  // 参考：https://github.com/tailwindlabs/tailwindcss/blob/main/packages/tailwindcss/src/utilities.ts#L1205
  property("--tw-translate-x", "0"),
  property("--tw-translate-y", "0"),
  property("--tw-translate-z", "0"),
  // 参考：https://github.com/tailwindlabs/tailwindcss/blob/main/packages/tailwindcss/src/utilities.ts#L1285
  property("--tw-scale-x", "1"),
  property("--tw-scale-y", "1"),
  property("--tw-scale-z", "1"),
  // 参考：https://github.com/tailwindlabs/tailwindcss/blob/main/packages/tailwindcss/src/utilities.ts#L1424
  property("--tw-rotate-x"),
  property("--tw-rotate-y"),
  property("--tw-rotate-z"),
  property("--tw-skew-x"),
  property("--tw-skew-y"),
  // 参考：https://github.com/tailwindlabs/tailwindcss/blob/main/packages/tailwindcss/src/utilities.ts#L1641C13-L1641C88
  property("--tw-pan-x"),
  property("--tw-pan-y"),
  property("--tw-pinch-zoom"),
  // 参考：https://github.com/tailwindlabs/tailwindcss/blob/main/packages/tailwindcss/src/utilities.ts#L1688C38-L1688C95
  property("--tw-scroll-snap-strictness", "proximity", "*"),
  // 参考：https://github.com/tailwindlabs/tailwindcss/blob/main/packages/tailwindcss/src/utilities.ts#L1688C38-L1688C95
  property("--tw-space-x-reverse", "0"),
  property("--tw-space-y-reverse", "0"),
  // 参考：https://github.com/tailwindlabs/tailwindcss/blob/main/packages/tailwindcss/src/utilities.ts#L2169C22-L2169C60
  property("--tw-border-style", "solid"),
  property("--tw-divide-x-reverse", "0"),
  property("--tw-divide-y-reverse", "0"),
  property("--tw-gradient-position", "initial"),
  property("--tw-gradient-from", "#0000", "<color>"),
  property("--tw-gradient-via", "#0000", "<color>"),
  property("--tw-gradient-to", "#0000", "<color>"),
  property("--tw-gradient-stops", "initial"),
  property("--tw-gradient-via-stops", "initial"),
  property("--tw-gradient-from-position", "0%", "<length-percentage>"),
  property("--tw-gradient-via-position", "50%", "<length-percentage>"),
  property("--tw-gradient-to-position", "100%", "<length-percentage>"),
  property("--tw-mask-linear", "linear-gradient(#fff, #fff)"),
  property("--tw-mask-radial", "linear-gradient(#fff, #fff)"),
  property("--tw-mask-conic", "linear-gradient(#fff, #fff)"),
  property("--tw-mask-left", "linear-gradient(#fff, #fff)"),
  property("--tw-mask-right", "linear-gradient(#fff, #fff)"),
  property("--tw-mask-bottom", "linear-gradient(#fff, #fff)"),
  property("--tw-mask-top", "linear-gradient(#fff, #fff)"),
  property("--tw-mask-linear-position", "0deg"),
  property("--tw-mask-linear-from-position", "0%"),
  property("--tw-mask-linear-to-position", "100%"),
  property("--tw-mask-linear-from-color", "black"),
  property("--tw-mask-linear-to-color", "transparent"),
  property("--tw-mask-radial-from-position", "0%"),
  property("--tw-mask-radial-to-position", "100%"),
  property("--tw-mask-radial-from-color", "black"),
  property("--tw-mask-radial-to-color", "transparent"),
  property("--tw-mask-radial-shape", "ellipse"),
  property("--tw-mask-radial-size", "farthest-corner"),
  property("--tw-mask-radial-position", "center"),
  property("--tw-mask-conic-position", "0deg"),
  property("--tw-mask-conic-from-position", "0%"),
  property("--tw-mask-conic-to-position", "100%"),
  property("--tw-mask-conic-from-color", "black"),
  property("--tw-mask-conic-to-color", "transparent"),
  property("--tw-font-weight"),
  property("--tw-blur"),
  property("--tw-brightness"),
  property("--tw-contrast"),
  property("--tw-grayscale"),
  property("--tw-hue-rotate"),
  property("--tw-invert"),
  property("--tw-opacity"),
  property("--tw-saturate"),
  property("--tw-sepia"),
  property("--tw-drop-shadow"),
  property("--tw-drop-shadow-color"),
  property("--tw-drop-shadow-alpha", "100%", "<percentage>"),
  property("--tw-drop-shadow-size"),
  property("--tw-backdrop-blur"),
  property("--tw-backdrop-brightness"),
  property("--tw-backdrop-contrast"),
  property("--tw-backdrop-grayscale"),
  property("--tw-backdrop-hue-rotate"),
  property("--tw-backdrop-invert"),
  property("--tw-backdrop-opacity"),
  property("--tw-backdrop-saturate"),
  property("--tw-backdrop-sepia"),
  property("--tw-duration", "initial"),
  property("--tw-ease", "initial"),
  property("--tw-content", '""'),
  property("--tw-contain-size"),
  property("--tw-contain-layout"),
  property("--tw-contain-paint"),
  property("--tw-contain-style"),
  property("--tw-leading"),
  property("--tw-tracking"),
  property("--tw-ordinal"),
  property("--tw-slashed-zero"),
  property("--tw-numeric-figure"),
  property("--tw-numeric-spacing"),
  property("--tw-numeric-fraction"),
  property("--tw-outline-style", "solid"),
  property("--tw-text-shadow-color", "initial"),
  property("--tw-text-shadow-alpha", "100%", "<percentage>"),
  property("--tw-shadow", nullShadow),
  property("--tw-shadow-color", "initial"),
  property("--tw-shadow-alpha", "100%", "<percentage>"),
  property("--tw-inset-shadow", nullShadow),
  property("--tw-inset-shadow-color", "initial"),
  property("--tw-inset-shadow-alpha", "100%", "<percentage>"),
  property("--tw-ring-color"),
  property("--tw-ring-shadow", nullShadow),
  property("--tw-inset-ring-color"),
  property("--tw-inset-ring-shadow", nullShadow),
  // Legacy 旧版变量兼容
  property("--tw-ring-inset"),
  property("--tw-ring-offset-width", "0px", "<length>"),
  property("--tw-ring-offset-color", "#fff"),
  property("--tw-ring-offset-shadow", nullShadow)
];
for (const edge of ["top", "right", "bottom", "left"]) {
  nodes.push(
    property(`--tw-mask-${edge}-from-position`, "0%"),
    property(`--tw-mask-${edge}-to-position`, "100%"),
    property(`--tw-mask-${edge}-from-color`, "black"),
    property(`--tw-mask-${edge}-to-color`, "transparent")
  );
}
var cssVarsV4_default = nodes;

// src/compat/tailwindcss-v4.ts
var OKLAB_SUFFIX = "in oklab";
var INFINITY_CALC_REGEXP = /calc\(\s*infinity\s*\*\s*(?:\d+(?:\.\d*)?|\.\d+)r?px/;
var RADIUS_THRESHOLD = 1e5;
var CLAMP_PX = 9999;
function isTailwindcssV4(options) {
  return options?.majorVersion === 4;
}
function testIfRootHostForV4(node) {
  return node.type === "rule" && node.selector.includes(":root") && node.selector.includes(":host");
}
var cssVarsV4Nodes = cssVarsV4_default.map((x) => {
  return new Declaration({
    prop: x.prop,
    value: x.value
  });
});
function isTailwindcssV4ModernCheck(atRule) {
  return atRule.name === "supports" && [
    /-webkit-hyphens\s*:\s*none/,
    /margin-trim\s*:\s*inline/,
    /-moz-orient\s*:\s*inline/,
    /color\s*:\s*rgb\(\s*from\s+red\s+r\s+g\s+b\s*\)/
  ].every((regex) => regex.test(atRule.params));
}
function normalizeTailwindcssV4Declaration(decl) {
  if (decl.prop === "--tw-gradient-position" && decl.value.endsWith(OKLAB_SUFFIX)) {
    decl.value = decl.value.slice(0, decl.value.length - OKLAB_SUFFIX.length);
    return true;
  }
  if (INFINITY_CALC_REGEXP.test(decl.value)) {
    decl.value = `${CLAMP_PX}px`;
    return true;
  }
  if (decl.prop.includes("radius")) {
    const next = decl.value.replace(
      /\b([+-]?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\s*(r?px)\b/gi,
      (m, num) => {
        const n = Number(num);
        if (!Number.isFinite(n)) {
          return `${CLAMP_PX}px`;
        }
        if (/e/i.test(String(num)) || n > RADIUS_THRESHOLD) {
          return `${CLAMP_PX}px`;
        }
        return m;
      }
    );
    if (next !== decl.value) {
      decl.value = next;
      return true;
    }
  }
  return false;
}

// src/compat/uni-app-x.ts
function isUniAppXEnabled(options) {
  return Boolean(options?.uniAppX);
}
function stripUnsupportedPseudoForUniAppX(node, enabled) {
  if (!enabled) {
    return;
  }
  node.remove();
}
function stripUnsupportedNodeForUniAppX(node, options) {
  if (!isUniAppXEnabled(options)) {
    return false;
  }
  if (node.type === "tag" || node.type === "attribute" || node.type === "pseudo") {
    node.remove();
    return true;
  }
  return false;
}
function shouldRemoveEmptyRuleForUniAppX(rule, options) {
  return isUniAppXEnabled(options) && rule.nodes.length === 0;
}

// src/constants.ts
var postcssPlugin = "postcss-weapp-tailwindcss-rename-plugin";

// src/selectorParser/before-after.ts
import psp from "postcss-selector-parser";
var beforeAfterStateRef = null;
var beforeAfterParser = psp((selectors) => {
  const state = beforeAfterStateRef;
  if (!state) {
    return;
  }
  selectors.walkPseudos((s) => {
    if (s.parent?.length === 1) {
      if (/^:?:before$/.test(s.value)) {
        state.before = true;
      }
      if (/^:?:after$/.test(s.value)) {
        state.after = true;
      }
    }
  });
});
function isOnlyBeforeAndAfterPseudoElement(node) {
  const state = {
    before: false,
    after: false
  };
  beforeAfterStateRef = state;
  beforeAfterParser.astSync(node);
  beforeAfterStateRef = null;
  return state.before && state.after;
}

// src/selectorParser/fallback.ts
import psp3 from "postcss-selector-parser";

// src/selectorParser/utils.ts
import psp2 from "postcss-selector-parser";
function normalizeTransformOptions(options) {
  return {
    lossless: false,
    updateSelector: true,
    ...options
  };
}
function mklist(node) {
  return [
    node,
    psp2.combinator({
      value: "+"
    }),
    node.clone()
  ];
}
function composeIsPseudoAst(strs) {
  if (typeof strs === "string") {
    return mklist(psp2.tag({
      value: strs
    }));
  }
  if (strs.length > 1) {
    return mklist(psp2.pseudo({
      value: ":is",
      nodes: strs.map(
        (str) => psp2.tag({
          value: str
        })
      )
    }));
  }
  return mklist(psp2.tag({
    value: strs[0]
  }));
}
function getCombinatorSelectorAst(options) {
  let childCombinatorReplaceValue = mklist(psp2.tag({ value: "view" }));
  const { cssChildCombinatorReplaceValue } = options;
  if (typeof cssChildCombinatorReplaceValue === "string" || Array.isArray(cssChildCombinatorReplaceValue) && cssChildCombinatorReplaceValue.length > 0) {
    childCombinatorReplaceValue = composeIsPseudoAst(cssChildCombinatorReplaceValue);
  }
  return childCombinatorReplaceValue;
}

// src/selectorParser/fallback.ts
var fallbackRemoveCache = /* @__PURE__ */ new WeakMap();
var fallbackDefaultKey = {};
function getFallbackRemove(_rule, options) {
  const cacheKey = options ?? fallbackDefaultKey;
  let entry = fallbackRemoveCache.get(cacheKey);
  if (!entry) {
    const uniAppX = isUniAppXEnabled(options);
    let currentRule;
    const parser = psp3((selectors) => {
      const activeRule = currentRule;
      let maybeImportantId = false;
      selectors.walk((selector, idx) => {
        if (idx === 0 && (selector.type === "id" || selector.type === "class" || selector.type === "attribute")) {
          maybeImportantId = true;
        }
        if (selector.type === "universal") {
          selector.parent?.remove();
        } else if (selector.type === "pseudo") {
          if (selector.value === ":is") {
            if (maybeImportantId && selector.nodes[0]?.type === "selector") {
              selector.replaceWith(selector.nodes[0]);
            } else {
              selector.parent?.remove();
            }
          } else if (selector.value === ":not") {
            for (const x of selector.nodes) {
              if (x.nodes.length === 1 && x.nodes[0].type === "id" && x.nodes[0].value === "#") {
                x.nodes = [
                  psp3.tag({
                    value: "#n"
                  })
                ];
              }
            }
          } else if (selector.value === ":where") {
            for (const n of selector.nodes) {
              for (const node of n.nodes) {
                if (node.type === "attribute") {
                  node.remove();
                }
              }
            }
          }
        } else if (selector.type === "attribute") {
          if (selector.attribute === "hidden") {
            activeRule?.remove();
          }
        }
      });
      selectors.walk((selector) => {
        if (selector.type === "pseudo") {
          if (selector.value === ":where") {
            const res = selector.nodes.every((x) => x.nodes.length === 0);
            if (res) {
              selector.remove();
            }
          } else if (selector.type === "pseudo") {
            stripUnsupportedPseudoForUniAppX(selector, uniAppX);
          }
        }
      });
    });
    const rawTransformSync = parser.transformSync.bind(parser);
    const transform = (targetRule) => {
      currentRule = targetRule;
      try {
        rawTransformSync(targetRule, normalizeTransformOptions());
      } finally {
        currentRule = void 0;
      }
    };
    parser.transformSync = ((input, opts) => {
      if (input && typeof input === "object" && "type" in input) {
        const maybeRule = input;
        if (maybeRule.type === "rule") {
          currentRule = input;
          try {
            return rawTransformSync(input, normalizeTransformOptions(opts));
          } finally {
            currentRule = void 0;
          }
        }
      }
      return rawTransformSync(input, opts);
    });
    entry = {
      parser,
      transform
    };
    fallbackRemoveCache.set(cacheKey, entry);
  }
  return entry.parser;
}

// src/selectorParser/rule-transformer.ts
import psp4 from "postcss-selector-parser";

// src/shared.ts
import { escape, MappingChars2String } from "@weapp-core/escape";
function internalCssSelectorReplacer(selectors, options = {
  escapeMap: MappingChars2String
}) {
  const { escapeMap } = options;
  return escape(selectors, {
    map: escapeMap
  });
}
function composeIsPseudo(strs) {
  if (typeof strs === "string") {
    return strs;
  }
  if (strs.length > 1) {
    return `:is(${strs.join(",")})`;
  }
  return strs.join("");
}

// src/selectorParser/rule-transformer.ts
var ruleTransformCache = /* @__PURE__ */ new WeakMap();
var MIRROR_PROP_PAIRS = [
  ["margin-top", "margin-bottom"],
  ["margin-left", "margin-right"],
  ["margin-inline-start", "margin-inline-end"],
  ["margin-block-start", "margin-block-end"],
  ["border-top-width", "border-bottom-width"],
  ["border-left-width", "border-right-width"],
  ["border-inline-start-width", "border-inline-end-width"],
  ["border-block-start-width", "border-block-end-width"]
];
var MIRROR_PROP_MAP = /* @__PURE__ */ new Map();
var SPACING_PROP_SET = /* @__PURE__ */ new Set();
for (const [a, b] of MIRROR_PROP_PAIRS) {
  MIRROR_PROP_MAP.set(a, b);
  MIRROR_PROP_MAP.set(b, a);
  SPACING_PROP_SET.add(a);
  SPACING_PROP_SET.add(b);
}
var LEGACY_WEBKIT_SPACING_PROPS = /* @__PURE__ */ new Set([
  "-webkit-margin-start",
  "-webkit-margin-end",
  "-webkit-margin-before",
  "-webkit-margin-after"
]);
var VAR_REFERENCE_PATTERN = /var\(/i;
function dedupeSpacingProps(rule) {
  const grouped = /* @__PURE__ */ new Map();
  for (const node of rule.nodes) {
    if (node.type !== "decl") {
      continue;
    }
    if (!SPACING_PROP_SET.has(node.prop)) {
      continue;
    }
    const list = grouped.get(node.prop);
    if (list) {
      list.push(node);
    } else {
      grouped.set(node.prop, [node]);
    }
  }
  for (const [, declarations] of grouped) {
    if (declarations.length <= 1) {
      continue;
    }
    const unique = [];
    const seenValues = /* @__PURE__ */ new Set();
    for (const decl of declarations) {
      if (decl.parent !== rule) {
        continue;
      }
      const key = `${decl.important ? "!important@@" : ""}${decl.value}`;
      if (seenValues.has(key)) {
        decl.remove();
        continue;
      }
      seenValues.add(key);
      unique.push(decl);
    }
    if (unique.length <= 1) {
      continue;
    }
    const literals = unique.filter((decl) => !VAR_REFERENCE_PATTERN.test(decl.value));
    const variables = unique.filter((decl) => VAR_REFERENCE_PATTERN.test(decl.value));
    if (variables.length === 0 || literals.length === 0) {
      continue;
    }
    const ordered = [...literals, ...variables];
    const alreadyOrdered = ordered.every((decl, index) => decl === unique[index]);
    if (alreadyOrdered) {
      continue;
    }
    const anchor = unique[unique.length - 1]?.next() ?? void 0;
    for (const decl of unique) {
      decl.remove();
    }
    for (const decl of ordered) {
      if (anchor) {
        rule.insertBefore(anchor, decl);
      } else {
        rule.append(decl);
      }
    }
  }
}
function isNotLastChildPseudo(node) {
  if (!node || node.type !== "pseudo" || node.value !== ":not") {
    return false;
  }
  const selectors = node.nodes;
  if (!selectors || selectors.length !== 1) {
    return false;
  }
  const firstSelector = selectors[0];
  if (firstSelector.type !== "selector") {
    return false;
  }
  const target = firstSelector.nodes?.[0];
  return Boolean(target && target.type === "pseudo" && target.value === ":last-child");
}
function transformSpacingSelector(nodes2, options) {
  if (!nodes2 || nodes2.length === 0) {
    return false;
  }
  for (let idx = 0; idx < nodes2.length; idx++) {
    const current = nodes2[idx];
    if (current.type !== "class" && current.type !== "nesting") {
      continue;
    }
    const combinator = nodes2[idx + 1];
    if (!combinator || combinator.type !== "combinator" || combinator.value !== ">") {
      continue;
    }
    const candidate = nodes2[idx + 2];
    if (!isNotLastChildPseudo(candidate)) {
      continue;
    }
    const ast = getCombinatorSelectorAst(options);
    candidate.replaceWith(...ast);
    return true;
  }
  return false;
}
function normalizeSpacingDeclarations(rule) {
  for (const node of [...rule.nodes]) {
    if (node.type !== "decl") {
      continue;
    }
    if (LEGACY_WEBKIT_SPACING_PROPS.has(node.prop)) {
      node.remove();
      continue;
    }
    const mirror = MIRROR_PROP_MAP.get(node.prop);
    if (mirror) {
      node.prop = mirror;
    }
  }
  dedupeSpacingProps(rule);
}
function flattenWherePseudo(node, context, index, parent) {
  if (isUniAppXEnabled(context.options)) {
    node.value = ":is";
  }
  if (index === 0 && node.length === 1) {
    const targetSelector = node.nodes?.[0];
    if (targetSelector && targetSelector.type === "selector" && transformSpacingSelector(targetSelector.nodes, context.options)) {
      context.requiresSpacingNormalization = true;
    }
    node.replaceWith(...node.nodes);
    if (parent && parent.type === "selector" && parent.length === 0) {
      parent.remove();
    }
  }
}
function handleClassNode(node, context) {
  if (node.type !== "class") {
    return;
  }
  node.value = internalCssSelectorReplacer(node.value, { escapeMap: context.options.escapeMap });
}
function handleUniversalNode(node, context) {
  if (node.type !== "universal") {
    return;
  }
  const replacement = context.options.cssSelectorReplacement?.universal;
  if (replacement) {
    node.value = composeIsPseudo(replacement);
  }
}
function shouldRemoveHoverSelector(selector, options) {
  if (!options.cssRemoveHoverPseudoClass) {
    return false;
  }
  return selector.nodes.some((node) => node.type === "pseudo" && node.value === ":hover");
}
function isHiddenOrTemplateNotPseudo(node) {
  if (!node || node.type !== "pseudo" || node.value !== ":not") {
    return false;
  }
  const selector = node.first;
  if (!selector || selector.type !== "selector") {
    return false;
  }
  const first = selector.first;
  if (!first) {
    return false;
  }
  if (first.type === "attribute") {
    return first.attribute === "hidden";
  }
  if (first.type === "tag") {
    return first.value === "template";
  }
  return false;
}
function handleCombinatorNode(node, index, context) {
  if (node.type !== "combinator" || node.value !== ">") {
    return;
  }
  const nodes2 = node.parent?.nodes;
  if (!nodes2) {
    return;
  }
  const first = nodes2[index + 1];
  const second = nodes2[index + 2];
  const third = nodes2[index + 3];
  if (isHiddenOrTemplateNotPseudo(first) && second && second.type === "combinator" && (second.value === "~" || second.value === "+") && isHiddenOrTemplateNotPseudo(third)) {
    const ast = getCombinatorSelectorAst(context.options);
    nodes2.splice(index + 1, 3, ...ast);
  }
}
function handlePseudoNode(node, index, context, parent) {
  if (node.type !== "pseudo") {
    return;
  }
  if (node.value === ":root" && context.options.cssSelectorReplacement?.root) {
    node.value = composeIsPseudo(context.options.cssSelectorReplacement.root);
    return;
  }
  if (node.value === ":where") {
    flattenWherePseudo(node, context, index, parent);
  }
}
function handleTagOrAttribute(node, context) {
  stripUnsupportedNodeForUniAppX(node, context.options);
}
function handleSelectorNode(selector, context) {
  if (shouldRemoveHoverSelector(selector, context.options)) {
    selector.remove();
    return;
  }
  if (transformSpacingSelector(selector.nodes, context.options)) {
    context.requiresSpacingNormalization = true;
  }
}
function transformSelectors(selectors, context) {
  selectors.walk((node, index) => {
    const parent = node.parent?.type === "selector" ? node.parent : void 0;
    switch (node.type) {
      case "class":
        handleClassNode(node, context);
        break;
      case "universal":
        handleUniversalNode(node, context);
        break;
      case "selector":
        handleSelectorNode(node, context);
        break;
      case "pseudo":
        if (!isNotLastChildPseudo(node)) {
          handlePseudoNode(node, index, context, parent);
        }
        break;
      case "combinator":
        handleCombinatorNode(node, index, context);
        break;
      case "tag":
      case "attribute":
        handleTagOrAttribute(node, context);
        break;
      default:
        break;
    }
  });
  if (context.requiresSpacingNormalization) {
    normalizeSpacingDeclarations(context.rule);
  }
  selectors.walk((node) => {
    if (node.type === "selector" && node.length === 0) {
      node.remove();
    }
  });
  if (selectors.length === 0) {
    context.rule.remove();
  }
}
function createRuleTransformer(options) {
  let context;
  const transform = (selectors) => {
    if (!context) {
      return;
    }
    transformSelectors(selectors, context);
  };
  const parser = psp4(transform);
  return (rule) => {
    context = {
      options,
      requiresSpacingNormalization: false,
      rule
    };
    try {
      parser.transformSync(rule, normalizeTransformOptions());
    } finally {
      context = void 0;
    }
  };
}
function ruleTransformSync(rule, options) {
  let transformer = ruleTransformCache.get(options);
  if (!transformer) {
    transformer = createRuleTransformer(options);
    ruleTransformCache.set(options, transformer);
  }
  transformer(rule);
}

// src/plugins/post.ts
function normalizeSelectorList(value) {
  if (value === void 0 || value === false) {
    return [];
  }
  return Array.isArray(value) ? value.filter(Boolean) : [value];
}
function getSpecificityMatchingName(options) {
  const feature = options.cssPresetEnv?.features?.["is-pseudo-class"];
  if (feature && typeof feature === "object" && "specificityMatchingName" in feature) {
    const specificityName = feature.specificityMatchingName;
    return typeof specificityName === "string" && specificityName.length > 0 ? specificityName : void 0;
  }
  return void 0;
}
function createRootSpecificityCleaner(options) {
  const specificityMatchingName = getSpecificityMatchingName(options);
  const selectors = normalizeSelectorList(options.cssSelectorReplacement?.root);
  if (!specificityMatchingName || selectors.length === 0) {
    return void 0;
  }
  const suffix = `:not(.${specificityMatchingName})`;
  const targets = selectors.map((selector) => selector?.trim()).filter((selector) => Boolean(selector?.length)).map((selector) => ({
    match: `${selector}${suffix}`,
    spacedMatch: `${selector} ${suffix}`,
    replacement: selector
  }));
  if (!targets.length) {
    return void 0;
  }
  return (rule) => {
    if (!rule.selectors || rule.selectors.length === 0) {
      return;
    }
    const next = rule.selectors.map((selector) => {
      let updated = selector;
      for (const target of targets) {
        if (updated.includes(target.match)) {
          updated = updated.split(target.match).join(target.replacement);
        }
        if (updated.includes(target.spacedMatch)) {
          updated = updated.split(target.spacedMatch).join(target.replacement);
        }
      }
      return updated;
    });
    rule.selectors = next;
  };
}
var logicalPropMap = /* @__PURE__ */ new Map([
  // margin 方向映射
  ["margin-inline-start", "margin-left"],
  ["margin-inline-end", "margin-right"],
  ["margin-block-start", "margin-top"],
  ["margin-block-end", "margin-bottom"],
  // padding 方向映射
  ["padding-inline-start", "padding-left"],
  ["padding-inline-end", "padding-right"],
  ["padding-block-start", "padding-top"],
  ["padding-block-end", "padding-bottom"],
  // border 方向映射
  ["border-inline-start", "border-left"],
  ["border-inline-end", "border-right"],
  ["border-block-start", "border-top"],
  ["border-block-end", "border-bottom"],
  ["border-inline-start-width", "border-left-width"],
  ["border-inline-end-width", "border-right-width"]
]);
var variablePriorityProps = /* @__PURE__ */ new Set([
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-bottom",
  "border-left-width",
  "border-right-width",
  "border-top-width",
  "border-bottom-width"
]);
function getCanonicalProp(prop) {
  return logicalPropMap.get(prop) ?? prop;
}
function normalizeCalcValue(value) {
  if (!value.includes("calc")) {
    return value;
  }
  let next = value;
  let prev;
  do {
    prev = next;
    next = prev.replace(/calc\(\s*calc\(/gi, "calc((");
  } while (next !== prev);
  return next.replace(/calc\(\s*(1\s*-\s*var\([^()]+\))\s*\)/gi, "($1)");
}
function hasVariableReference(value) {
  return value.includes("var(");
}
function dedupeDeclarations(rule) {
  const entries = [];
  for (const node of [...rule.nodes]) {
    if (node.type !== "decl") {
      continue;
    }
    const decl = node;
    const normalizedValue = normalizeCalcValue(decl.value);
    if (normalizedValue !== decl.value) {
      decl.value = normalizedValue;
    }
    const canonicalProp = getCanonicalProp(decl.prop);
    entries.push({
      decl,
      normalizedValue,
      canonicalProp,
      importantKey: decl.important ? "!important" : "",
      isLogical: canonicalProp !== decl.prop
    });
  }
  const seen = /* @__PURE__ */ new Map();
  for (const entry of entries) {
    const key = `${entry.canonicalProp}${entry.importantKey}@@${entry.normalizedValue}`;
    const existing = seen.get(key);
    if (!existing) {
      seen.set(key, entry);
      continue;
    }
    if (existing.isLogical && !entry.isLogical) {
      existing.decl.remove();
      seen.set(key, entry);
    } else {
      entry.decl.remove();
    }
  }
  const reorderGroups = /* @__PURE__ */ new Map();
  for (const node of rule.nodes) {
    if (node.type !== "decl") {
      continue;
    }
    const canonical = getCanonicalProp(node.prop);
    if (!variablePriorityProps.has(canonical)) {
      continue;
    }
    const existing = reorderGroups.get(canonical);
    if (existing) {
      existing.push(node);
    } else {
      reorderGroups.set(canonical, [node]);
    }
  }
  for (const declarations of reorderGroups.values()) {
    if (declarations.length <= 1) {
      continue;
    }
    const literals = declarations.filter((decl) => !hasVariableReference(decl.value));
    const variables = declarations.filter((decl) => hasVariableReference(decl.value));
    if (literals.length === 0 || variables.length === 0) {
      continue;
    }
    const ordered = [...literals, ...variables];
    let needReorder = false;
    for (let index = 0; index < ordered.length; index++) {
      if (ordered[index] !== declarations[index]) {
        needReorder = true;
        break;
      }
    }
    if (!needReorder) {
      continue;
    }
    const anchor = declarations[declarations.length - 1]?.next() ?? void 0;
    for (const decl of declarations) {
      decl.remove();
    }
    for (const decl of ordered) {
      if (anchor) {
        rule.insertBefore(anchor, decl);
      } else {
        rule.append(decl);
      }
    }
  }
  const literalSeen = /* @__PURE__ */ new Map();
  for (const node of [...rule.nodes]) {
    if (node.type !== "decl") {
      continue;
    }
    const canonical = getCanonicalProp(node.prop);
    if (!variablePriorityProps.has(canonical)) {
      continue;
    }
    if (hasVariableReference(node.value)) {
      continue;
    }
    const existing = literalSeen.get(canonical);
    if (existing) {
      node.remove();
    } else {
      literalSeen.set(canonical, node);
    }
  }
}
var postcssWeappTailwindcssPostPlugin = (options) => {
  const opts = defu(options, {
    isMainChunk: true
  });
  const p = {
    postcssPlugin
  };
  const cleanRootSpecificity = createRootSpecificityCleaner(opts);
  const enableMainChunkTransforms = opts.isMainChunk !== false;
  if (enableMainChunkTransforms || cleanRootSpecificity) {
    const fallbackRemove = enableMainChunkTransforms ? getFallbackRemove(void 0, opts) : void 0;
    p.RuleExit = (rule) => {
      if (enableMainChunkTransforms) {
        fallbackRemove?.transformSync(rule);
      }
      cleanRootSpecificity?.(rule);
      if (enableMainChunkTransforms) {
        dedupeDeclarations(rule);
        if (rule.selectors.length === 0 || rule.selectors.length === 1 && rule.selector.trim() === "") {
          rule.remove();
        }
        if (shouldRemoveEmptyRuleForUniAppX(rule, opts)) {
          rule.remove();
        }
      }
    };
  }
  if (enableMainChunkTransforms) {
    p.DeclarationExit = (decl) => normalizeTailwindcssV4Declaration(decl);
    p.AtRuleExit = (atRule) => {
      if (opts.cssRemoveProperty && atRule.name === "property") {
        atRule.remove();
      }
      atRule.nodes?.length === 0 && atRule.remove();
    };
  }
  return p;
};
postcssWeappTailwindcssPostPlugin.postcss = true;

// src/plugins/pre.ts
import { defu as defu2 } from "@weapp-tailwindcss/shared";

// src/mp.ts
import { Declaration as Declaration2, Rule } from "postcss";

// src/cssVarsV3.ts
var cssVarsV3_default = [
  {
    prop: "--tw-border-spacing-x",
    value: "0"
  },
  {
    prop: "--tw-border-spacing-y",
    value: "0"
  },
  {
    prop: "--tw-translate-x",
    value: "0"
  },
  {
    prop: "--tw-translate-y",
    value: "0"
  },
  {
    prop: "--tw-rotate",
    value: "0"
  },
  {
    prop: "--tw-skew-x",
    value: "0"
  },
  {
    prop: "--tw-skew-y",
    value: "0"
  },
  {
    prop: "--tw-scale-x",
    value: "1"
  },
  {
    prop: "--tw-scale-y",
    value: "1"
  },
  {
    prop: "--tw-pan-x",
    value: " "
  },
  {
    prop: "--tw-pan-y",
    value: " "
  },
  {
    prop: "--tw-pinch-zoom",
    value: " "
  },
  {
    prop: "--tw-scroll-snap-strictness",
    value: "proximity"
  },
  {
    prop: "--tw-gradient-from-position",
    value: " "
  },
  {
    prop: "--tw-gradient-via-position",
    value: " "
  },
  {
    prop: "--tw-gradient-to-position",
    value: " "
  },
  {
    prop: "--tw-ordinal",
    value: " "
  },
  {
    prop: "--tw-slashed-zero",
    value: " "
  },
  {
    prop: "--tw-numeric-figure",
    value: " "
  },
  {
    prop: "--tw-numeric-spacing",
    value: " "
  },
  {
    prop: "--tw-numeric-fraction",
    value: " "
  },
  {
    prop: "--tw-ring-inset",
    value: " "
  },
  {
    prop: "--tw-ring-offset-width",
    value: "0px"
  },
  {
    prop: "--tw-ring-offset-color",
    value: "#fff"
  },
  {
    prop: "--tw-ring-color",
    value: "rgb(59 130 246 / 0.5)"
  },
  {
    prop: "--tw-ring-offset-shadow",
    value: "0 0 #0000"
  },
  {
    prop: "--tw-ring-shadow",
    value: "0 0 #0000"
  },
  {
    prop: "--tw-shadow",
    value: "0 0 #0000"
  },
  {
    prop: "--tw-shadow-colored",
    value: "0 0 #0000"
  },
  {
    prop: "--tw-blur",
    value: " "
  },
  {
    prop: "--tw-brightness",
    value: " "
  },
  {
    prop: "--tw-contrast",
    value: " "
  },
  {
    prop: "--tw-grayscale",
    value: " "
  },
  {
    prop: "--tw-hue-rotate",
    value: " "
  },
  {
    prop: "--tw-invert",
    value: " "
  },
  {
    prop: "--tw-saturate",
    value: " "
  },
  {
    prop: "--tw-sepia",
    value: " "
  },
  {
    prop: "--tw-drop-shadow",
    value: " "
  },
  {
    prop: "--tw-backdrop-blur",
    value: " "
  },
  {
    prop: "--tw-backdrop-brightness",
    value: " "
  },
  {
    prop: "--tw-backdrop-contrast",
    value: " "
  },
  {
    prop: "--tw-backdrop-grayscale",
    value: " "
  },
  {
    prop: "--tw-backdrop-hue-rotate",
    value: " "
  },
  {
    prop: "--tw-backdrop-invert",
    value: " "
  },
  {
    prop: "--tw-backdrop-opacity",
    value: " "
  },
  {
    prop: "--tw-backdrop-saturate",
    value: " "
  },
  {
    prop: "--tw-backdrop-sepia",
    value: " "
  },
  {
    prop: "--tw-contain-size",
    value: " "
  },
  {
    prop: "--tw-contain-layout",
    value: " "
  },
  {
    prop: "--tw-contain-paint",
    value: " "
  },
  {
    prop: "--tw-contain-style",
    value: " "
  }
];

// src/mp.ts
var cssVarsV3Nodes = cssVarsV3_default.map((x) => {
  return new Declaration2({
    prop: x.prop,
    value: x.value
  });
});
function testIfVariablesScope(node, count = 2) {
  if (isOnlyBeforeAndAfterPseudoElement(node)) {
    const nodes2 = node.nodes;
    let c = 0;
    for (const tryTestDecl of nodes2) {
      if (tryTestDecl && tryTestDecl.type === "decl" && tryTestDecl.prop.startsWith("--tw-")) {
        c++;
      }
      if (c >= count) {
        return true;
      }
    }
    return false;
  }
  return false;
}
function testIfTwBackdrop(node, count = 2) {
  if (node.type === "rule" && node.selector === "::backdrop") {
    const nodes2 = node.nodes;
    let c = 0;
    for (const tryTestDecl of nodes2) {
      if (tryTestDecl && tryTestDecl.type === "decl" && tryTestDecl.prop.startsWith("--tw-")) {
        c++;
      }
      if (c >= count) {
        return true;
      }
    }
    return false;
  }
  return false;
}
function makePseudoVarRule() {
  const pseudoVarRule = new Rule({
    // selectors: ['::before', '::after'],
    selector: "::before,::after"
  });
  pseudoVarRule.append(
    new Declaration2({
      prop: "--tw-content",
      value: '""'
    })
  );
  return pseudoVarRule;
}
function remakeCssVarSelector(selectors, options) {
  const { cssPreflightRange, cssSelectorReplacement } = options;
  if (cssPreflightRange === "all" && !selectors.includes(":not(not)")) {
    selectors.push(":not(not)");
  }
  if (cssSelectorReplacement) {
    if (Array.isArray(cssSelectorReplacement.universal)) {
      if (!cssSelectorReplacement.universal.every((x) => {
        return selectors.includes(x);
      }) && !selectors.includes("*")) {
        selectors.unshift("*");
      }
    } else if (typeof cssSelectorReplacement.universal === "string" && !selectors.includes(cssSelectorReplacement.universal) && !selectors.includes("*")) {
      selectors.unshift("*");
    }
  }
  return selectors;
}
function commonChunkPreflight(node, options) {
  const { ctx, cssInjectPreflight, injectAdditionalCssVarScope } = options;
  if (testIfVariablesScope(node)) {
    ctx?.markVariablesScope(node);
    node.selectors = remakeCssVarSelector(node.selectors, options);
    node.before(makePseudoVarRule());
    if (typeof cssInjectPreflight === "function") {
      node.append(...cssInjectPreflight());
    }
  }
  const isTailwindcss4 = isTailwindcssV4(options);
  if (injectAdditionalCssVarScope && (isTailwindcss4 ? testIfRootHostForV4(node) : testIfTwBackdrop(node))) {
    const syntheticRule = new Rule({
      selectors: ["*", "::after", "::before"],
      nodes: isTailwindcss4 ? cssVarsV4Nodes : cssVarsV3Nodes
    });
    syntheticRule.selectors = remakeCssVarSelector(syntheticRule.selectors, options);
    node.before(syntheticRule);
    node.before(makePseudoVarRule());
    if (typeof cssInjectPreflight === "function") {
      syntheticRule.append(...cssInjectPreflight());
    }
  }
}

// src/plugins/pre.ts
function isAtMediaHover(atRule) {
  return /media\(\s*hover\s*:\s*hover\s*\)/.test(atRule.name) || atRule.name === "media" && /\(\s*hover\s*:\s*hover\s*\)/.test(atRule.params);
}
var postcssWeappTailwindcssPrePlugin = (options) => {
  const opts = defu2(options, { isMainChunk: true });
  const p = {
    postcssPlugin,
    Rule(rule) {
      ruleTransformSync(rule, opts);
    },
    AtRule(atRule) {
      if (isAtMediaHover(atRule)) {
        if (atRule.nodes) {
          atRule.replaceWith(atRule.nodes);
        } else {
          atRule.remove();
        }
      } else if (atRule.name === "supports") {
        if (/color-mix/.test(atRule.params)) {
          atRule.remove();
        }
      } else if (atRule.name === "layer") {
        if (atRule.nodes === void 0 || Array.isArray(atRule.nodes) && atRule.nodes.length === 0) {
          atRule.remove();
        }
      }
    }
  };
  if (opts.isMainChunk) {
    let layerProperties;
    p.Once = (root) => {
      root.walkAtRules((atRule) => {
        if (atRule.name === "layer") {
          if (atRule.params === "properties") {
            if (atRule.nodes === void 0 || atRule.nodes?.length === 0) {
              layerProperties = atRule;
            } else if (atRule.first?.type === "atrule" && isTailwindcssV4ModernCheck(atRule.first)) {
              if (layerProperties) {
                layerProperties.replaceWith(atRule.first.nodes);
                atRule.remove();
              } else {
                atRule.replaceWith(atRule.first.nodes);
              }
            }
          } else {
            atRule.replaceWith(atRule.nodes);
          }
        } else if (isTailwindcssV4ModernCheck(atRule)) {
          if (atRule.first?.type === "atrule" && atRule.first.name === "layer") {
            atRule.replaceWith(atRule.first.nodes);
          }
        }
      });
      root.walkRules((rule) => {
        commonChunkPreflight(rule, opts);
      });
    };
  }
  return p;
};
postcssWeappTailwindcssPrePlugin.postcss = true;

// src/pipeline.ts
var STAGE_ORDER = ["pre", "normal", "post"];
function normalizeUserPlugins(plugins) {
  if (!plugins) {
    return [];
  }
  if (Array.isArray(plugins)) {
    return plugins.filter(Boolean);
  }
  if (typeof plugins === "object") {
    return Object.values(plugins).filter(Boolean);
  }
  return [];
}
function createStaticDefinition(id, stage, plugin) {
  return {
    id,
    stage,
    prepare: () => ({
      id,
      stage,
      createPlugin: () => plugin
    })
  };
}
function createPipelineDefinitions(options) {
  const stages = {
    pre: [],
    normal: [],
    post: []
  };
  const userPlugins = normalizeUserPlugins(options.postcssOptions?.plugins);
  userPlugins.forEach((plugin, index) => {
    stages.pre.push(createStaticDefinition(`pre:user-${index}`, "pre", plugin));
  });
  stages.pre.push({
    id: "pre:core",
    stage: "pre",
    prepare: () => ({
      id: "pre:core",
      stage: "pre",
      createPlugin: () => postcssWeappTailwindcssPrePlugin(options)
    })
  });
  stages.normal.push({
    id: "normal:preset-env",
    stage: "normal",
    prepare: () => ({
      id: "normal:preset-env",
      stage: "normal",
      createPlugin: () => postcssPresetEnv(options.cssPresetEnv)
    })
  });
  stages.normal.push({
    id: "normal:color-functional-fallback",
    stage: "normal",
    prepare: () => ({
      id: "normal:color-functional-fallback",
      stage: "normal",
      createPlugin: () => createColorFunctionalFallback()
    })
  });
  stages.normal.push({
    id: "normal:px-transform",
    stage: "normal",
    prepare: () => {
      const plugin = getPxTransformPlugin(options);
      return plugin ? {
        id: "normal:px-transform",
        stage: "normal",
        createPlugin: () => plugin
      } : void 0;
    }
  });
  stages.normal.push({
    id: "normal:rem-transform",
    stage: "normal",
    prepare: () => {
      const plugin = getRemTransformPlugin(options);
      return plugin ? {
        id: "normal:rem-transform",
        stage: "normal",
        createPlugin: () => plugin
      } : void 0;
    }
  });
  stages.normal.push({
    id: "normal:calc",
    stage: "normal",
    prepare: () => {
      const plugin = getCalcPlugin(options);
      return plugin ? {
        id: "normal:calc",
        stage: "normal",
        createPlugin: () => plugin
      } : void 0;
    }
  });
  stages.normal.push({
    id: "normal:custom-property-cleaner",
    stage: "normal",
    prepare: () => {
      const plugin = getCustomPropertyCleaner(options);
      return plugin ? {
        id: "normal:custom-property-cleaner",
        stage: "normal",
        createPlugin: () => plugin
      } : void 0;
    }
  });
  stages.post.push({
    id: "post:core",
    stage: "post",
    prepare: () => ({
      id: "post:core",
      stage: "post",
      createPlugin: () => postcssWeappTailwindcssPostPlugin(options)
    })
  });
  return STAGE_ORDER.flatMap((stage) => stages[stage]);
}
function createStylePipeline(options) {
  options.ctx = createContext();
  const preparedNodes = createPipelineDefinitions(options).map((definition) => definition.prepare(options)).filter(Boolean);
  if (preparedNodes.length === 0) {
    return {
      nodes: [],
      plugins: []
    };
  }
  const stageSizes = /* @__PURE__ */ new Map();
  preparedNodes.forEach((node) => {
    stageSizes.set(node.stage, (stageSizes.get(node.stage) ?? 0) + 1);
  });
  const stageIndices = /* @__PURE__ */ new Map();
  const nodes2 = [];
  const size = preparedNodes.length;
  preparedNodes.forEach((node, index) => {
    const stageIndex = stageIndices.get(node.stage) ?? 0;
    const context = {
      stage: node.stage,
      index,
      size,
      stageIndex,
      stageSize: stageSizes.get(node.stage) ?? 0,
      previous: index > 0 ? {
        id: preparedNodes[index - 1].id,
        stage: preparedNodes[index - 1].stage
      } : void 0,
      next: index < size - 1 ? {
        id: preparedNodes[index + 1].id,
        stage: preparedNodes[index + 1].stage
      } : void 0
    };
    stageIndices.set(node.stage, stageIndex + 1);
    nodes2.push({
      id: node.id,
      stage: node.stage,
      plugin: node.createPlugin(context),
      context
    });
  });
  return {
    nodes: nodes2,
    plugins: nodes2.map((node) => node.plugin)
  };
}

// src/preflight.ts
function createInjectPreflight(options) {
  const result = [];
  if (options && typeof options === "object") {
    const entries = Object.entries(options);
    for (const [prop, value] of entries) {
      if (value !== false) {
        result.push({
          prop,
          value: value.toString()
        });
      }
    }
  }
  return () => {
    return result;
  };
}

// src/handler.ts
function createProcessOptions(options) {
  return {
    from: void 0,
    ...options.postcssOptions?.options ?? {}
  };
}
var pipelineCache = /* @__PURE__ */ new WeakMap();
var processOptionsCache = /* @__PURE__ */ new WeakMap();
var processOptionsSourceCache = /* @__PURE__ */ new WeakMap();
function getCachedPipeline(options) {
  let pipeline = pipelineCache.get(options);
  if (!pipeline) {
    pipeline = createStylePipeline(options);
    pipelineCache.set(options, pipeline);
  }
  return pipeline;
}
function getCachedProcessOptions(options) {
  const source = options.postcssOptions?.options;
  let cached = processOptionsCache.get(options);
  const cachedSource = processOptionsSourceCache.get(options);
  if (!cached || cachedSource !== source) {
    cached = createProcessOptions(options);
    processOptionsCache.set(options, cached);
    processOptionsSourceCache.set(options, source);
  }
  return { ...cached };
}
function styleHandler(rawSource, options) {
  const plugins = getCachedPipeline(options).plugins;
  const processOptions = getCachedProcessOptions(options);
  return postcss(plugins).process(
    rawSource,
    processOptions
  ).async();
}
function createStyleHandler(options) {
  const cachedOptions = defuOverrideArray3(
    options,
    getDefaultOptions(options)
  );
  cachedOptions.cssInjectPreflight = createInjectPreflight(cachedOptions.cssPreflight);
  getCachedPipeline(cachedOptions);
  getCachedProcessOptions(cachedOptions);
  const handler = ((rawSource, opt) => {
    const resolvedOptions = defuOverrideArray3(opt, cachedOptions);
    return styleHandler(
      rawSource,
      resolvedOptions
    );
  });
  handler.getPipeline = (opt) => {
    if (!opt) {
      return getCachedPipeline(cachedOptions);
    }
    const resolvedOptions = defuOverrideArray3(opt, cachedOptions);
    return getCachedPipeline(resolvedOptions);
  };
  return handler;
}
export {
  createInjectPreflight,
  createStyleHandler,
  createStylePipeline,
  internalCssSelectorReplacer
};
