'use strict';

const SYMBOL_TABLE = {
  BACKQUOTE: "`",
  TILDE: "~",
  EXCLAM: "!",
  AT: "@",
  NUMBERSIGN: "#",
  DOLLAR: "$",
  PERCENT: "%",
  CARET: "^",
  AMPERSAND: "&",
  ASTERISK: "*",
  PARENLEFT: "(",
  PARENRIGHT: ")",
  MINUS: "-",
  UNDERSCORE: "_",
  EQUAL: "=",
  PLUS: "+",
  BRACKETLEFT: "[",
  BRACELEFT: "{",
  BRACKETRIGHT: "]",
  BRACERIGHT: "}",
  SEMICOLON: ";",
  COLON: ":",
  QUOTE: "'",
  DOUBLEQUOTE: '"',
  BACKSLASH: "\\",
  BAR: "|",
  COMMA: ",",
  LESS: "<",
  PERIOD: ".",
  GREATER: ">",
  SLASH: "/",
  QUESTION: "?",
  SPACE: " ",
  DOT: ".",
  HASH: "#"
};
const ESCAPE_CHARACTER_CODES = [
  ["[", "b"],
  ["]", "B"],
  ["(", "p"],
  [")", "P"],
  ["#", "h"],
  ["!", "e"],
  ["/", "f"],
  ["\\", "r"],
  [".", "d"],
  [":", "c"],
  ["%", "v"],
  [",", "m"],
  ["'", "a"],
  ['"', "q"],
  ["*", "x"],
  ["&", "n"],
  ["@", "t"],
  ["{", "k"],
  ["}", "K"],
  ["+", "u"],
  [";", "j"],
  ["<", "l"],
  ["~", "w"],
  ["=", "z"],
  [">", "g"],
  ["?", "Q"],
  ["^", "y"],
  ["`", "i"],
  ["|", "o"],
  ["$", "s"]
];
function buildMapping(prefix) {
  return ESCAPE_CHARACTER_CODES.reduce((acc, [char, code]) => {
    acc[char] = `${prefix}${code}`;
    return acc;
  }, {});
}
const SIMPLE_TOKEN_PREFIX = "_";
const COMPLEX_TOKEN_PREFIX = "_c";
const ComplexMappingChars2String = buildMapping(COMPLEX_TOKEN_PREFIX);
const ComplexMappingChars2StringEntries = Object.entries(ComplexMappingChars2String);
const MappingChars2String = buildMapping(SIMPLE_TOKEN_PREFIX);
const MappingChars2StringEntries = Object.entries(MappingChars2String);
const MAX_ASCII_CHAR_CODE = 127;

const ESCAPE_PREFIX = "_";
const HYPHEN = "-";

const DEFAULT_ESCAPE_MAPPING = MappingChars2String;
const COMPLEX_ESCAPE_MAPPING = ComplexMappingChars2String;
const DEFAULT_ESCAPE_KEYS = new Set(Object.keys(DEFAULT_ESCAPE_MAPPING));
const escapeMappingCache = /* @__PURE__ */ new WeakMap();
const inverseMappingCache = /* @__PURE__ */ new WeakMap();
function hasOwnKey(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}
function createEscapeMapping(customMap) {
  if (!customMap) {
    return DEFAULT_ESCAPE_MAPPING;
  }
  if (customMap === DEFAULT_ESCAPE_MAPPING || customMap === COMPLEX_ESCAPE_MAPPING) {
    return customMap;
  }
  const cached = escapeMappingCache.get(customMap);
  if (cached) {
    return cached;
  }
  if (Object.keys(customMap).length === 0) {
    escapeMappingCache.set(customMap, DEFAULT_ESCAPE_MAPPING);
    return DEFAULT_ESCAPE_MAPPING;
  }
  const merged = { ...DEFAULT_ESCAPE_MAPPING, ...customMap };
  escapeMappingCache.set(customMap, merged);
  return merged;
}
function createUnescapeMapping(customMap) {
  return customMap;
}
function buildInverseMapping(mapping) {
  const inverse = {};
  const tokens = /* @__PURE__ */ new Set();
  for (const [key, value] of Object.entries(mapping)) {
    inverse[value] = key;
    tokens.add(value);
  }
  const sortedTokens = Array.from(tokens).sort((a, b) => b.length - a.length);
  return { inverse, tokens: sortedTokens };
}
function createInverseMapping(mapping) {
  const cached = inverseMappingCache.get(mapping);
  if (cached) {
    return cached;
  }
  const built = buildInverseMapping(mapping);
  inverseMappingCache.set(mapping, built);
  return built;
}
function primeInverseCache(mapping) {
  inverseMappingCache.set(mapping, buildInverseMapping(mapping));
}
primeInverseCache(DEFAULT_ESCAPE_MAPPING);
primeInverseCache(COMPLEX_ESCAPE_MAPPING);

const DIGIT_MIN_CODE = 48;
const DIGIT_MAX_CODE = 57;
function isAsciiNumber(code) {
  return code >= DIGIT_MIN_CODE && code <= DIGIT_MAX_CODE;
}
function isAllowedClassName(className) {
  return /^[\w-]+$/.test(className);
}

function escapeLeadingCharacter(char, nextChar, ignoreHead) {
  if (ignoreHead) {
    return char;
  }
  const code = char.codePointAt(0);
  if (isAsciiNumber(code)) {
    return `${ESCAPE_PREFIX}${char}`;
  }
  if (char === HYPHEN) {
    if (!nextChar) {
      return `${ESCAPE_PREFIX}${char}`;
    }
    if (isAsciiNumber(nextChar.codePointAt(0))) {
      return `${ESCAPE_PREFIX}${char}`;
    }
  }
  return char;
}
function escape(selectors, options) {
  if (selectors.length === 0) {
    return "";
  }
  const map = createEscapeMapping(options?.map);
  const ignoreHead = options?.ignoreHead ?? false;
  const usingDefaultMap = map === DEFAULT_ESCAPE_MAPPING;
  const sb = [];
  const characters = Array.from(selectors);
  for (let index = 0; index < characters.length; index++) {
    const char = characters[index];
    const code = char.codePointAt(0);
    if (code > MAX_ASCII_CHAR_CODE) {
      sb.push(`u${code.toString(16)}`);
      continue;
    }
    if (usingDefaultMap) {
      if (DEFAULT_ESCAPE_KEYS.has(char)) {
        sb.push(DEFAULT_ESCAPE_MAPPING[char]);
        continue;
      }
    } else if (hasOwnKey(map, char)) {
      sb.push(map[char]);
      continue;
    }
    if (index === 0) {
      sb.push(escapeLeadingCharacter(char, characters[index + 1], ignoreHead));
      continue;
    }
    sb.push(char);
  }
  return sb.join("");
}

function toEscapeOptions(options) {
  return options ?? {};
}
function toUnescapeOptions(options) {
  return options ?? {};
}

const UNICODE_PREFIX = "u";
const HEX_RADIX = 16;
function isHexDigit(char) {
  const code = char.codePointAt(0);
  return code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102;
}
function decodeUnicodeSequence(value, index) {
  if (value[index] !== UNICODE_PREFIX) {
    return void 0;
  }
  let cursor = index + 1;
  while (cursor < value.length) {
    const nextChar = value[cursor];
    if (!nextChar || !isHexDigit(nextChar)) {
      break;
    }
    cursor += 1;
  }
  if (cursor === index + 1) {
    return void 0;
  }
  const hex = value.slice(index + 1, cursor);
  const codePoint = Number.parseInt(hex, HEX_RADIX);
  if (Number.isNaN(codePoint) || codePoint <= MAX_ASCII_CHAR_CODE) {
    return void 0;
  }
  return {
    char: String.fromCodePoint(codePoint),
    length: cursor - index
  };
}

function unescape(value, options) {
  if (value.length === 0) {
    return "";
  }
  const map = createUnescapeMapping(options?.map);
  const ignoreHead = options?.ignoreHead ?? false;
  const { inverse, tokens } = map ? createInverseMapping(map) : { inverse: {}, tokens: [] };
  let cursor = 0;
  let result = "";
  while (cursor < value.length) {
    if (!ignoreHead && cursor === 0 && value[cursor] === ESCAPE_PREFIX) {
      const nextChar2 = value[cursor + 1];
      if (nextChar2 && isAsciiNumber(nextChar2.codePointAt(0))) {
        result += nextChar2;
        cursor += 2;
        continue;
      }
      if (nextChar2 === HYPHEN) {
        const thirdChar = value[cursor + 2];
        if (!thirdChar || isAsciiNumber(thirdChar.codePointAt(0))) {
          result += HYPHEN;
          cursor += 2;
          continue;
        }
      }
    }
    const decodedUnicode = decodeUnicodeSequence(value, cursor);
    if (decodedUnicode) {
      result += decodedUnicode.char;
      cursor += decodedUnicode.length;
      continue;
    }
    let matchedToken = false;
    for (const token of tokens) {
      if (token.length === 0) {
        continue;
      }
      if (value.startsWith(token, cursor)) {
        result += inverse[token];
        cursor += token.length;
        matchedToken = true;
        break;
      }
    }
    if (matchedToken) {
      continue;
    }
    result += value[cursor];
    cursor++;
  }
  if (ignoreHead || result.length === 0 || !result.startsWith(ESCAPE_PREFIX)) {
    return result;
  }
  const nextChar = result[1];
  if (!nextChar) {
    return result.slice(1);
  }
  let shouldStrip = isAsciiNumber(nextChar.codePointAt(0));
  if (!shouldStrip && nextChar === HYPHEN) {
    const thirdChar = result[2];
    shouldStrip = !thirdChar || isAsciiNumber(thirdChar.codePointAt(0));
  }
  return shouldStrip ? result.slice(1) : result;
}

const __areExportsLoaded = true;

exports.ComplexMappingChars2String = ComplexMappingChars2String;
exports.ComplexMappingChars2StringEntries = ComplexMappingChars2StringEntries;
exports.MAX_ASCII_CHAR_CODE = MAX_ASCII_CHAR_CODE;
exports.MappingChars2String = MappingChars2String;
exports.MappingChars2StringEntries = MappingChars2StringEntries;
exports.SYMBOL_TABLE = SYMBOL_TABLE;
exports.__areExportsLoaded = __areExportsLoaded;
exports.escape = escape;
exports.isAllowedClassName = isAllowedClassName;
exports.isAsciiNumber = isAsciiNumber;
exports.toEscapeOptions = toEscapeOptions;
exports.toUnescapeOptions = toUnescapeOptions;
exports.unescape = unescape;
